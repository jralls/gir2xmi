# _______________________________________________________________
#
# DTD for UML including Action Semantics
# Generated by Adaptive Repository version 1.2
# _______________________________________________________________
# _______________________________________________________________
#
# XMI is the top-level XML element for XMI transfer text
# _______________________________________________________________

namespace UML = "http://www.omg.org/UML"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

XMI =
  element XMI {
    attlist.XMI,
    XMI.header?,
    XMI.content?,
    XMI.difference*,
    XMI.extensions*
  }
attlist.XMI &=
  [ a:defaultValue = "1.1" ] attribute xmi.version { string "1.1" }?,
  attribute timestamp { text }?,
  attribute verified { "true" | "false" }?

# _______________________________________________________________
#
# XMI.header contains documentation and identifies the model,
# metamodel, and metametamodel
# _______________________________________________________________

XMI.header =
  element XMI.header {
    attlist.XMI.header,
    XMI.documentation?,
    XMI.model*,
    XMI.metamodel*,
    XMI.metametamodel*,
    XMI.import*
  }
attlist.XMI.header &= empty

# _______________________________________________________________
#
# documentation for transfer data
# _______________________________________________________________

XMI.documentation =
  element XMI.documentation {
    attlist.XMI.documentation,
    (text
     | XMI.owner
     | XMI.contact
     | XMI.longDescription
     | XMI.shortDescription
     | XMI.exporter
     | XMI.exporterVersion
     | XMI.notice)*
  }
attlist.XMI.documentation &= empty
XMI.owner = element XMI.owner { attlist.XMI.owner, any }
attlist.XMI.owner &= empty
XMI.contact = element XMI.contact { attlist.XMI.contact, any }
attlist.XMI.contact &= empty
XMI.longDescription =
  element XMI.longDescription { attlist.XMI.longDescription, any }
attlist.XMI.longDescription &= empty
XMI.shortDescription =
  element XMI.shortDescription { attlist.XMI.shortDescription, any }
attlist.XMI.shortDescription &= empty
XMI.exporter = element XMI.exporter { attlist.XMI.exporter, any }
attlist.XMI.exporter &= empty
XMI.exporterVersion =
  element XMI.exporterVersion { attlist.XMI.exporterVersion, any }
attlist.XMI.exporterVersion &= empty
XMI.exporterID = element XMI.exporterID { attlist.XMI.exporterID, any }
attlist.XMI.exporterID &= empty
XMI.notice = element XMI.notice { attlist.XMI.notice, any }
attlist.XMI.notice &= empty

# _______________________________________________________________
#
# XMI.element.att defines the attributes that each XML element
# that corresponds to a metamodel class must have to conform to
# the XMI specification.
# _______________________________________________________________

XMI.element.att =
  attribute xmi.id { xsd:ID }?,
  attribute xmi.label { text }?,
  attribute xmi.uuid { text }?

# _______________________________________________________________
#
# XMI.link.att defines the attributes that each XML element that
# corresponds to a metamodel class must have to enable it to
# function as a simple XLink as well as refer to model
# constructs within the same XMI file.
# _______________________________________________________________

XMI.link.att =
  attribute href { text }?,
  attribute xmi.idref { xsd:IDREF }?

# _______________________________________________________________
#
# XMI.model identifies the model(s) being transferred
# _______________________________________________________________

XMI.model = element XMI.model { attlist.XMI.model, any }
attlist.XMI.model &=
  XMI.link.att,
  attribute xmi.name { text },
  attribute xmi.version { text }?

# _______________________________________________________________
#
# XMI.metamodel identifies the metamodel(s) for the transferred
# data
# _______________________________________________________________

XMI.metamodel = element XMI.metamodel { attlist.XMI.metamodel, any }
attlist.XMI.metamodel &=
  XMI.link.att,
  attribute xmi.name { text },
  attribute xmi.version { text }?

# _______________________________________________________________
#
# XMI.metametamodel identifies the metametamodel(s) for the
# transferred data
# _______________________________________________________________

XMI.metametamodel =
  element XMI.metametamodel { attlist.XMI.metametamodel, any }
attlist.XMI.metametamodel &=
  XMI.link.att,
  attribute xmi.name { text },
  attribute xmi.version { text }?

# _______________________________________________________________
#
# XMI.import identifies imported metamodel(s)
# _______________________________________________________________

XMI.import = element XMI.import { attlist.XMI.import, any }
attlist.XMI.import &=
  XMI.link.att,
  attribute xmi.name { text },
  attribute xmi.version { text }?

# _______________________________________________________________
#
# XMI.content is the actual data being transferred
# _______________________________________________________________

XMI.content = element XMI.content { attlist.XMI.content, any }
attlist.XMI.content &= empty

# _______________________________________________________________
#
# XMI.extensions contains data to transfer that does not conform
# to the metamodel(s) in the header
# _______________________________________________________________

XMI.extensions = element XMI.extensions { attlist.XMI.extensions, any }
attlist.XMI.extensions &= attribute xmi.extender { text }

# _______________________________________________________________
#
# extension contains information related to a specific model
# construct that is not defined in the metamodel(s) in the header
# _______________________________________________________________

XMI.extension = element XMI.extension { attlist.XMI.extension, any }
attlist.XMI.extension &=
  XMI.element.att,
  XMI.link.att,
  attribute xmi.extender { text },
  attribute xmi.extenderID { text }?

# _______________________________________________________________
#
# XMI.difference holds XML elements representing differences to a
# base model
# _______________________________________________________________

XMI.difference =
  element XMI.difference {
    attlist.XMI.difference,
    (XMI.difference | XMI.delete | XMI.add | XMI.replace)*
  }
attlist.XMI.difference &= XMI.element.att, XMI.link.att

# _______________________________________________________________
#
# XMI.delete represents a deletion from a base model
# _______________________________________________________________

XMI.delete = element XMI.delete { attlist.XMI.delete, empty }
attlist.XMI.delete &= XMI.element.att, XMI.link.att

# _______________________________________________________________
#
# XMI.add represents an addition to a base model
# _______________________________________________________________

XMI.add = element XMI.add { attlist.XMI.add, any }
attlist.XMI.add &=
  XMI.element.att,
  XMI.link.att,
  [ a:defaultValue = "-1" ] attribute xmi.position { text }?

# _______________________________________________________________
#
# XMI.replace represents the replacement of a model construct
# with another model construct in a base model
# _______________________________________________________________

XMI.replace = element XMI.replace { attlist.XMI.replace, any }
attlist.XMI.replace &=
  XMI.element.att,
  XMI.link.att,
  [ a:defaultValue = "-1" ] attribute xmi.position { text }?

# _______________________________________________________________
#
# XMI.reference may be used to refer to data types not defined in
# the metamodel
# _______________________________________________________________

XMI.reference = element XMI.reference { attlist.XMI.reference, any }
attlist.XMI.reference &= XMI.link.att
#-------------------------------------------------------------------------------
#
# Begin UML Schema
#
#------------------------------------------------------------------------------
# ========= UML:Data_Types =========

UML.AggregationKind = "none" | "aggregate" | "composite"
UML.CallConcurrencyKind = "sequential" | "guarded" | "concurrent"
UML.ChangeableKind = "changeable" | "frozen" | "addOnly"
UML.OrderingKind = "unordered" | "ordered"
UML.ParameterDirectionKind = "in" | "inout" | "out" | "return"
UML.ScopeKind = "instance" | "classifier"
UML.VisibilityKind = "public" | "protected" | "private" | "package"
UML.PseudostateKind =
  "choice"
  | "deepHistory"
  | "fork"
  | "initial"
  | "join"
  | "junction"
  | "shallowHistory"

# ========= UML:Multiplicity =========

Multiplicity.range =
  element UML:Multiplicity.range {
    attlist.Multiplicity.range, MultiplicityRange*
  }
attlist.Multiplicity.range &= empty
UML.MultiplicityFeatures = XMI.extension | Multiplicity.range
UML.MultiplicityAtts = XMI.element.att, XMI.link.att
Multiplicity =
  element UML:Multiplicity {
    attlist.Multiplicity, UML.MultiplicityFeatures*
  }
attlist.Multiplicity &= UML.MultiplicityAtts

# ========= UML:MultiplicityRange =========

MultiplicityRange.lower =
  element UML:MultiplicityRange.lower {
    attlist.MultiplicityRange.lower, (text | XMI.reference)*
  }
attlist.MultiplicityRange.lower &= empty
MultiplicityRange.upper =
  element UML:MultiplicityRange.upper {
    attlist.MultiplicityRange.upper, (text | XMI.reference)*
  }
attlist.MultiplicityRange.upper &= empty
MultiplicityRange.multiplicity =
  element UML:MultiplicityRange.multiplicity {
    attlist.MultiplicityRange.multiplicity, Multiplicity*
  }
attlist.MultiplicityRange.multiplicity &= empty
UML.MultiplicityRangeFeatures =
  XMI.extension
  | MultiplicityRange.lower
  | MultiplicityRange.upper
  | MultiplicityRange.multiplicity
UML.MultiplicityRangeAtts =
  XMI.element.att,
  XMI.link.att,
  attribute lower { text }?,
  attribute upper { text }?,
  attribute multiplicity { xsd:IDREFS }?
MultiplicityRange =
  element UML:MultiplicityRange {
    attlist.MultiplicityRange, UML.MultiplicityRangeFeatures*
  }
attlist.MultiplicityRange &= UML.MultiplicityRangeAtts

# ========= UML:Expression =========

Expression.language =
  element UML:Expression.language {
    attlist.Expression.language, (text | XMI.reference)*
  }
attlist.Expression.language &= empty
Expression.body =
  element UML:Expression.body {
    attlist.Expression.body, (text | XMI.reference)*
  }
attlist.Expression.body &= empty
UML.ExpressionFeatures =
  XMI.extension | Expression.language | Expression.body
UML.ExpressionAtts =
  XMI.element.att,
  XMI.link.att,
  attribute language { text }?,
  attribute body { text }?
Expression =
  element UML:Expression { attlist.Expression, UML.ExpressionFeatures* }
attlist.Expression &= UML.ExpressionAtts

# ========= UML:BooleanExpression =========

UML.BooleanExpressionFeatures = UML.ExpressionFeatures
UML.BooleanExpressionAtts = UML.ExpressionAtts
BooleanExpression =
  element UML:BooleanExpression {
    attlist.BooleanExpression, UML.BooleanExpressionFeatures*
  }
attlist.BooleanExpression &= UML.BooleanExpressionAtts

# ========= UML:TypeExpression =========

UML.TypeExpressionFeatures = UML.ExpressionFeatures
UML.TypeExpressionAtts = UML.ExpressionAtts
TypeExpression =
  element UML:TypeExpression {
    attlist.TypeExpression, UML.TypeExpressionFeatures*
  }
attlist.TypeExpression &= UML.TypeExpressionAtts

# ========= UML:MappingExpression =========

UML.MappingExpressionFeatures = UML.ExpressionFeatures
UML.MappingExpressionAtts = UML.ExpressionAtts
MappingExpression =
  element UML:MappingExpression {
    attlist.MappingExpression, UML.MappingExpressionFeatures*
  }
attlist.MappingExpression &= UML.MappingExpressionAtts

# ========= UML:TimeExpression =========

UML.TimeExpressionFeatures = UML.ExpressionFeatures
UML.TimeExpressionAtts = UML.ExpressionAtts
TimeExpression =
  element UML:TimeExpression {
    attlist.TimeExpression, UML.TimeExpressionFeatures*
  }
attlist.TimeExpression &= UML.TimeExpressionAtts

# ========= UML:ArgListsExpression =========

UML.ArgListsExpressionFeatures = UML.ExpressionFeatures
UML.ArgListsExpressionAtts = UML.ExpressionAtts
ArgListsExpression =
  element UML:ArgListsExpression {
    attlist.ArgListsExpression, UML.ArgListsExpressionFeatures*
  }
attlist.ArgListsExpression &= UML.ArgListsExpressionAtts

# ========= UML:ProcedureExpression =========

UML.ProcedureExpressionFeatures = UML.ExpressionFeatures
UML.ProcedureExpressionAtts = UML.ExpressionAtts
ProcedureExpression =
  element UML:ProcedureExpression {
    attlist.ProcedureExpression, UML.ProcedureExpressionFeatures*
  }
attlist.ProcedureExpression &= UML.ProcedureExpressionAtts

# ============================ UML:Core ======================================
# ========================= The Top Level ====================================

# The Model Element generalizes all other types.
# ========= UML:Element =========

UML.ElementFeatures = XMI.extension
UML.ElementAtts = XMI.element.att, XMI.link.att
Element = element UML:Element { attlist.Element, UML.ElementFeatures* }
attlist.Element &= UML.ElementAtts

# ========= UML:ModelElement =========

ModelElement.name =
  element UML:ModelElement.name {
    attlist.ModelElement.name, (text | XMI.reference)*
  }
attlist.ModelElement.name &= empty
ModelElement.visibility =
  element UML:ModelElement.visibility {
    attlist.ModelElement.visibility, empty
  }
attlist.ModelElement.visibility &=
  attribute xmi.value { UML.VisibilityKind }
ModelElement.isSpecification =
  element UML:ModelElement.isSpecification {
    attlist.ModelElement.isSpecification, empty
  }
attlist.ModelElement.isSpecification &=
  attribute xmi.value { "true" | "false" }
ModelElement.namespace =
  element UML:ModelElement.namespace {
    attlist.ModelElement.namespace, Namespace*
  }
attlist.ModelElement.namespace &= empty
ModelElement.clientDependency =
  element UML:ModelElement.clientDependency {
    attlist.ModelElement.clientDependency, Dependency*
  }
attlist.ModelElement.clientDependency &= empty
ModelElement.constraint =
  element UML:ModelElement.constraint {
    attlist.ModelElement.constraint, Constraint*
  }
attlist.ModelElement.constraint &= empty
ModelElement.targetFlow =
  element UML:ModelElement.targetFlow {
    attlist.ModelElement.targetFlow, Flow*
  }
attlist.ModelElement.targetFlow &= empty
ModelElement.sourceFlow =
  element UML:ModelElement.sourceFlow {
    attlist.ModelElement.sourceFlow, Flow*
  }
attlist.ModelElement.sourceFlow &= empty
ModelElement.comment =
  element UML:ModelElement.comment {
    attlist.ModelElement.comment, Comment*
  }
attlist.ModelElement.comment &= empty
ModelElement.templateParameter =
  element UML:ModelElement.templateParameter {
    attlist.ModelElement.templateParameter, TemplateParameter*
  }
attlist.ModelElement.templateParameter &= empty
ModelElement.stereotype =
  element UML:ModelElement.stereotype {
    attlist.ModelElement.stereotype, Stereotype*
  }
attlist.ModelElement.stereotype &= empty
ModelElement.taggedValue =
  element UML:ModelElement.taggedValue {
    attlist.ModelElement.taggedValue, TaggedValue*
  }
attlist.ModelElement.taggedValue &= empty
UML.ModelElementFeatures =
  UML.ElementFeatures
  | ModelElement.name
  | ModelElement.visibility
  | ModelElement.isSpecification
  | ModelElement.namespace
  | ModelElement.clientDependency
  | ModelElement.constraint
  | ModelElement.targetFlow
  | ModelElement.sourceFlow
  | ModelElement.comment
  | ModelElement.templateParameter
  | ModelElement.stereotype
  | ModelElement.taggedValue
UML.ModelElementAtts =
  UML.ElementAtts,
  attribute name { text }?,
  attribute visibility { UML.VisibilityKind }?,
  attribute isSpecification { "true" | "false" }?,
  attribute namespace { xsd:IDREFS }?,
  attribute clientDependency { xsd:IDREFS }?,
  attribute constraint { xsd:IDREFS }?,
  attribute targetFlow { xsd:IDREFS }?,
  attribute sourceFlow { xsd:IDREFS }?,
  attribute comment { xsd:IDREFS }?,
  attribute stereotype { xsd:IDREFS }?
ModelElement =
  element UML:ModelElement {
    attlist.ModelElement, UML.ModelElementFeatures*
  }
attlist.ModelElement &= UML.ModelElementAtts

# ============= Namepace + GeneralizableElement => Classifier =================

# ========= UML:GeneralizableElement =========
# GeneralizableElement captures generalization (inheritance). Combined
# with Namespace it is the parent of Classifier.

GeneralizableElement.isRoot =
  element UML:GeneralizableElement.isRoot {
    attlist.GeneralizableElement.isRoot, empty
  }
attlist.GeneralizableElement.isRoot &=
  attribute xmi.value { "true" | "false" }
GeneralizableElement.isLeaf =
  element UML:GeneralizableElement.isLeaf {
    attlist.GeneralizableElement.isLeaf, empty
  }
attlist.GeneralizableElement.isLeaf &=
  attribute xmi.value { "true" | "false" }
GeneralizableElement.isAbstract =
  element UML:GeneralizableElement.isAbstract {
    attlist.GeneralizableElement.isAbstract, empty
  }
attlist.GeneralizableElement.isAbstract &=
  attribute xmi.value { "true" | "false" }
GeneralizableElement.generalization =
  element UML:GeneralizableElement.generalization {
    attlist.GeneralizableElement.generalization, Generalization*
  }
attlist.GeneralizableElement.generalization &= empty
UML.GeneralizableElementFeatures =
  UML.ModelElementFeatures
  | GeneralizableElement.isRoot
  | GeneralizableElement.isLeaf
  | GeneralizableElement.isAbstract
  | GeneralizableElement.generalization
UML.GeneralizableElementAtts =
  UML.ModelElementAtts,
  attribute isRoot { "true" | "false" }?,
  attribute isLeaf { "true" | "false" }?,
  attribute isAbstract { "true" | "false" }?,
  attribute generalization { xsd:IDREFS }?
GeneralizableElement =
  element UML:GeneralizableElement {
    attlist.GeneralizableElement, UML.GeneralizableElementFeatures*
  }
attlist.GeneralizableElement &= UML.GeneralizableElementAtts

# ========= UML:Namespace =========

# A Namespace.ownedElement is an inner container which can be a
# toplevel for a Classifier, Association, Collaboration, or
# Package. It's used for Models and Packages (at least by Umbrello);
# since it can contain just about anything, it allows nesting of
# models or packages within each other.

Namespace.ownedElement =
  element UML:Namespace.ownedElement {
    attlist.Namespace.ownedElement,
    (ModelElement
     | Instance
     | Object
     | LinkObject
     | DataValue
     | ComponentInstance
     | NodeInstance
     | SubsystemInstance
     | UseCaseInstance
     | AttributeLink
     | Link
     | LinkEnd
     | Stimulus
     | Procedure
     | ExtensionPoint
     | StateMachine
     | ActivityGraph
     | Event
     | TimeEvent
     | CallEvent
     | SignalEvent
     | ChangeEvent
     | StateVertex
     | State
     | CompositeState
     | SubmachineState
     | SubactivityState
     | SimpleState
     | ActionState
     | CallState
     | ObjectFlowState
     | FinalState
     | Pseudostate
     | SynchState
     | StubState
     | Transition
     | Guard
     | Message
     | Interaction
     | InteractionInstanceSet
     | CollaborationInstanceSet
     | Partition
     | Variable
     | ArgumentSpecification
     | PrimitiveFunction
     | ControlFlow
     | Action
     | CollectionAction
     | FilterAction
     | IterateAction
     | MapAction
     | ReduceAction
     | ConditionalAction
     | GroupAction
     | LoopAction
     | HandlerAction
     | PrimitiveAction
     | ApplyFunctionAction
     | CodeAction
     | LiteralValueAction
     | MarshalAction
     | NullAction
     | TestIdentityAction
     | UnmarshalAction
     | JumpAction
     | InvocationAction
     | AsynchronousInvocationAction
     | SynchronousInvocationAction
     | ClearAssociationAction
     | LinkAction
     | ReadLinkAction
     | WriteLinkAction
     | CreateLinkAction
     | CreateLinkObjectAction
     | DestroyLinkAction
     | ReadLinkObjectEndAction
     | ReadLinkObjectQualifierAction
     | AttributeAction
     | ClearAttributeAction
     | ReadAttributeAction
     | WriteAttributeAction
     | AddAttributeValueAction
     | RemoveAttributeValueAction
     | CreateObjectAction
     | DestroyObjectAction
     | ReadIsClassifiedObjectAction
     | ReclassifyObjectAction
     | ReadExtentAction
     | ReadSelfAction
     | StartObjectStateMachineAction
     | VariableAction
     | ClearVariableAction
     | ReadVariableAction
     | WriteVariableAction
     | AddVariableValueAction
     | RemoveVariableValueAction
     | ExplicitInvocationActtion
     | CallOperationAction
     | SendSignalAction
     | BroadcastSignalAction
     | CallProcedureAction
     | DataFlow
     | Pin
     | InputPin
     | OutputPin
     | GeneralizableElement
     | Collaboration
     | Classifier
     | Signal
     | Exception
     | UseCase
     | Actor
     | ClassifierRole
     | ClassifierInState
     | Class
     | AssociationClass
     | DataType
     | Primitive
     | Enumeration
     | ProgrammingLanguageDataType
     | Interface
     | Component
     | Node
     | Artifact
     | Subsystem
     | Association
     | AssociationRole
     | Stereotype
     | Package
     | Model
     | Namespace
     | Feature
     | StructuralFeature
     | Attribute
     | BehavioralFeature
     | Reception
     | Operation
     | Method
     | AssociationEnd
     | AssociationEndRole
     | Constraint
     | Relationship
     | Extend
     | Include
     | Generalization
     | Dependency
     | Abstraction
     | Usage
     | Binding
     | Permission
     | Flow
     | Parameter
     | Comment
     | EnumerationLiteral
     | TagDefinition
     | TaggedValue)*
  }
attlist.Namespace.ownedElement &= empty
UML.NamespaceFeatures =
  UML.ModelElementFeatures | Namespace.ownedElement
UML.NamespaceAtts = UML.ModelElementAtts
Namespace =
  element UML:Namespace { attlist.Namespace, UML.NamespaceFeatures* }
attlist.Namespace &= UML.NamespaceAtts

# ========= UML:Classifier =========

# Classifier is the generalization of (for Class Diagrams) Class,
# Interface, and Datatype. It is derived from Namespace and
# GeneralizableElement.

Classifier.feature =
  element UML:Classifier.feature {
    attlist.Classifier.feature,
    (Feature
     | StructuralFeature
     | Attribute
     | BehavioralFeature
     | Reception
     | Operation
     | Method)*
  }
attlist.Classifier.feature &= empty
Classifier.powertypeRange =
  element UML:Classifier.powertypeRange {
    attlist.Classifier.powertypeRange, Generalization*
  }
attlist.Classifier.powertypeRange &= empty
UML.ClassifierFeatures =
  UML.GeneralizableElementFeatures
  | Namespace.ownedElement
  | Classifier.feature
  | Classifier.powertypeRange
UML.ClassifierAtts =
  UML.GeneralizableElementAtts,
  attribute powertypeRange { xsd:IDREFS }?
Classifier =
  element UML:Classifier { attlist.Classifier, UML.ClassifierFeatures* }
attlist.Classifier &= UML.ClassifierAtts

# ========= UML:Class =========

Class.isActive =
  element UML:Class.isActive { attlist.Class.isActive, empty }
attlist.Class.isActive &= attribute xmi.value { "true" | "false" }
UML.ClassFeatures = UML.ClassifierFeatures | Class.isActive
UML.ClassAtts =
  UML.ClassifierAtts,
  attribute isActive { "true" | "false" }?
Class = element UML:Class { attlist.Class, UML.ClassFeatures* }
attlist.Class &= UML.ClassAtts

# ========= UML:DataType =========

UML.DataTypeFeatures = UML.ClassifierFeatures
UML.DataTypeAtts = UML.ClassifierAtts
DataType =
  element UML:DataType { attlist.DataType, UML.DataTypeFeatures* }
attlist.DataType &= UML.DataTypeAtts

# ========= UML:Primitive =========

UML.PrimitiveFeatures = UML.DataTypeFeatures
UML.PrimitiveAtts = UML.DataTypeAtts
Primitive =
  element UML:Primitive { attlist.Primitive, UML.PrimitiveFeatures* }
attlist.Primitive &= UML.PrimitiveAtts

# ========= UML:Enumeration =========

Enumeration.literal =
  element UML:Enumeration.literal {
    attlist.Enumeration.literal, EnumerationLiteral*
  }
attlist.Enumeration.literal &= empty
UML.EnumerationFeatures = UML.DataTypeFeatures | Enumeration.literal
UML.EnumerationAtts = UML.DataTypeAtts
Enumeration =
  element UML:Enumeration {
    attlist.Enumeration, UML.EnumerationFeatures*
  }
attlist.Enumeration &= UML.EnumerationAtts

# ========= UML:EnumerationLiteral =========

EnumerationLiteral.enumeration =
  element UML:EnumerationLiteral.enumeration {
    attlist.EnumerationLiteral.enumeration, Enumeration*
  }
attlist.EnumerationLiteral.enumeration &= empty
UML.EnumerationLiteralFeatures =
  UML.ModelElementFeatures | EnumerationLiteral.enumeration
UML.EnumerationLiteralAtts =
  UML.ModelElementAtts,
  attribute enumeration { xsd:IDREFS }?
EnumerationLiteral =
  element UML:EnumerationLiteral {
    attlist.EnumerationLiteral, UML.EnumerationLiteralFeatures*
  }
attlist.EnumerationLiteral &= UML.EnumerationLiteralAtts

# ========= UML:Interface =========
# Note that this doesn't match the
# spec, in that it allows an interface to have
# attributes. Associations, and Methods, which aren't permitted.

UML.InterfaceFeatures = UML.ClassifierFeatures
UML.InterfaceAtts = UML.ClassifierAtts
Interface =
  element UML:Interface { attlist.Interface, UML.InterfaceFeatures* }
attlist.Interface &= UML.InterfaceAtts

# ============================== Features ====================================

# ========= UML:Feature =========

# Feature is the parent class of Attribute (the only child of
# StructuredFeature), Operation, and Method (which are children of
# BehavioralFeature). It is a kind of ModelElement

Feature.ownerScope =
  element UML:Feature.ownerScope { attlist.Feature.ownerScope, empty }
attlist.Feature.ownerScope &= attribute xmi.value { UML.ScopeKind }
Feature.owner =
  element UML:Feature.owner { attlist.Feature.owner, Classifier* }
attlist.Feature.owner &= empty
UML.FeatureFeatures =
  UML.ModelElementFeatures | Feature.ownerScope | Feature.owner
UML.FeatureAtts =
  UML.ModelElementAtts,
  attribute ownerScope { UML.ScopeKind }?,
  attribute owner { xsd:IDREFS }?
Feature = element UML:Feature { attlist.Feature, UML.FeatureFeatures* }
attlist.Feature &= UML.FeatureAtts

# ========= UML:StructuralFeature =========

StructuralFeature.multiplicity =
  element UML:StructuralFeature.multiplicity {
    attlist.StructuralFeature.multiplicity, Multiplicity*
  }
attlist.StructuralFeature.multiplicity &= empty
StructuralFeature.changeability =
  element UML:StructuralFeature.changeability {
    attlist.StructuralFeature.changeability, empty
  }
attlist.StructuralFeature.changeability &=
  attribute xmi.value { UML.ChangeableKind }
StructuralFeature.targetScope =
  element UML:StructuralFeature.targetScope {
    attlist.StructuralFeature.targetScope, empty
  }
attlist.StructuralFeature.targetScope &=
  attribute xmi.value { UML.ScopeKind }
StructuralFeature.ordering =
  element UML:StructuralFeature.ordering {
    attlist.StructuralFeature.ordering, empty
  }
attlist.StructuralFeature.ordering &=
  attribute xmi.value { UML.OrderingKind }
StructuralFeature.type =
  element UML:StructuralFeature.type {
    attlist.StructuralFeature.type, Classifier*
  }
attlist.StructuralFeature.type &= empty
UML.StructuralFeatureFeatures =
  UML.FeatureFeatures
  | StructuralFeature.multiplicity
  | StructuralFeature.changeability
  | StructuralFeature.targetScope
  | StructuralFeature.ordering
  | StructuralFeature.type
UML.StructuralFeatureAtts =
  UML.FeatureAtts,
  attribute changeability { UML.ChangeableKind }?,
  attribute targetScope { UML.ScopeKind }?,
  attribute ordering { UML.OrderingKind }?,
  attribute type { xsd:IDREFS }?
StructuralFeature =
  element UML:StructuralFeature {
    attlist.StructuralFeature, UML.StructuralFeatureFeatures*
  }
attlist.StructuralFeature &= UML.StructuralFeatureAtts

# ========= UML:Attribute =========
# An attribute is a structuralFeature of a Classifier

Attribute.initialValue =
  element UML:Attribute.initialValue {
    attlist.Attribute.initialValue,
    (Expression
     | BooleanExpression
     | TypeExpression
     | MappingExpression
     | TimeExpression
     | ArgListsExpression
     | ProcedureExpression)*
  }
attlist.Attribute.initialValue &= empty
Attribute.associationEnd =
  element UML:Attribute.associationEnd {
    attlist.Attribute.associationEnd, AssociationEnd*
  }
attlist.Attribute.associationEnd &= empty
UML.AttributeFeatures =
  UML.StructuralFeatureFeatures
  | Attribute.initialValue
  | Attribute.associationEnd
UML.AttributeAtts =
  UML.StructuralFeatureAtts,
  attribute associationEnd { xsd:IDREFS }?
Attribute =
  element UML:Attribute { attlist.Attribute, UML.AttributeFeatures* }
attlist.Attribute &= UML.AttributeAtts

# ========= UML:BehavioralFeature =========
# BehavioralFeature generalizes Operation and Method -- but a Method
# is just the implementation of an Operation. Since the Operation is
# what holds the parameters, it is more useful for class modelling.

BehavioralFeature.isQuery =
  element UML:BehavioralFeature.isQuery {
    attlist.BehavioralFeature.isQuery, empty
  }
attlist.BehavioralFeature.isQuery &=
  attribute xmi.value { "true" | "false" }
BehavioralFeature.parameter =
  element UML:BehavioralFeature.parameter {
    attlist.BehavioralFeature.parameter, Parameter*
  }
attlist.BehavioralFeature.parameter &= empty
UML.BehavioralFeatureFeatures =
  UML.FeatureFeatures
  | BehavioralFeature.isQuery
  | BehavioralFeature.parameter
UML.BehavioralFeatureAtts =
  UML.FeatureAtts,
  attribute isQuery { "true" | "false" }?
BehavioralFeature =
  element UML:BehavioralFeature {
    attlist.BehavioralFeature, UML.BehavioralFeatureFeatures*
  }
attlist.BehavioralFeature &= UML.BehavioralFeatureAtts

# ========= UML:Operation =========

Operation.concurrency =
  element UML:Operation.concurrency {
    attlist.Operation.concurrency, empty
  }
attlist.Operation.concurrency &=
  attribute xmi.value { UML.CallConcurrencyKind }
Operation.isRoot =
  element UML:Operation.isRoot { attlist.Operation.isRoot, empty }
attlist.Operation.isRoot &= attribute xmi.value { "true" | "false" }
Operation.isLeaf =
  element UML:Operation.isLeaf { attlist.Operation.isLeaf, empty }
attlist.Operation.isLeaf &= attribute xmi.value { "true" | "false" }
Operation.isAbstract =
  element UML:Operation.isAbstract {
    attlist.Operation.isAbstract, empty
  }
attlist.Operation.isAbstract &= attribute xmi.value { "true" | "false" }
Operation.specification =
  element UML:Operation.specification {
    attlist.Operation.specification, (text | XMI.reference)*
  }
attlist.Operation.specification &= empty
UML.OperationFeatures =
  UML.BehavioralFeatureFeatures
  | Operation.concurrency
  | Operation.isRoot
  | Operation.isLeaf
  | Operation.isAbstract
  | Operation.specification
UML.OperationAtts =
  UML.BehavioralFeatureAtts,
  attribute concurrency { UML.CallConcurrencyKind }?,
  attribute isRoot { "true" | "false" }?,
  attribute isLeaf { "true" | "false" }?,
  attribute isAbstract { "true" | "false" }?,
  attribute specification { text }?
Operation =
  element UML:Operation { attlist.Operation, UML.OperationFeatures* }
attlist.Operation &= UML.OperationAtts

# ========= UML:Parameter =========
# A bit out of place, as it's a kind of ModelElememt, but it's here
# because it is closely associated with Operation.

Parameter.defaultValue =
  element UML:Parameter.defaultValue {
    attlist.Parameter.defaultValue,
    (Expression
     | BooleanExpression
     | TypeExpression
     | MappingExpression
     | TimeExpression
     | ArgListsExpression
     | ProcedureExpression)*
  }
attlist.Parameter.defaultValue &= empty
Parameter.kind =
  element UML:Parameter.kind { attlist.Parameter.kind, empty }
attlist.Parameter.kind &=
  attribute xmi.value { UML.ParameterDirectionKind }
Parameter.behavioralFeature =
  element UML:Parameter.behavioralFeature {
    attlist.Parameter.behavioralFeature, BehavioralFeature*
  }
attlist.Parameter.behavioralFeature &= empty
Parameter.type =
  element UML:Parameter.type { attlist.Parameter.type, Classifier* }
attlist.Parameter.type &= empty
UML.ParameterFeatures =
  UML.ModelElementFeatures
  | Parameter.defaultValue
  | Parameter.kind
  | Parameter.behavioralFeature
  | Parameter.type
UML.ParameterAtts =
  UML.ModelElementAtts,
  attribute kind { UML.ParameterDirectionKind }?,
  attribute behavioralFeature { xsd:IDREFS }?,
  attribute type { xsd:IDREFS }?
Parameter =
  element UML:Parameter { attlist.Parameter, UML.ParameterFeatures* }
attlist.Parameter &= UML.ParameterAtts

# ========= UML:Method =========
# A method is the instantiation of an Operation

Method.body =
  element UML:Method.body { attlist.Method.body, ProcedureExpression* }
attlist.Method.body &= empty
Method.specification =
  element UML:Method.specification {
    attlist.Method.specification, Operation*
  }
attlist.Method.specification &= empty
UML.MethodFeatures =
  UML.BehavioralFeatureFeatures | Method.body | Method.specification
UML.MethodAtts =
  UML.BehavioralFeatureAtts,
  attribute specification { xsd:IDREFS }?
Method = element UML:Method { attlist.Method, UML.MethodFeatures* }
attlist.Method &= UML.MethodAtts

#===================== Associations and Relationships ======================

# ========= UML:AssociationEnd =========

AssociationEnd.isNavigable =
  element UML:AssociationEnd.isNavigable {
    attlist.AssociationEnd.isNavigable, empty
  }
attlist.AssociationEnd.isNavigable &=
  attribute xmi.value { "true" | "false" }
AssociationEnd.ordering =
  element UML:AssociationEnd.ordering {
    attlist.AssociationEnd.ordering, empty
  }
attlist.AssociationEnd.ordering &=
  attribute xmi.value { UML.OrderingKind }
AssociationEnd.aggregation =
  element UML:AssociationEnd.aggregation {
    attlist.AssociationEnd.aggregation, empty
  }
attlist.AssociationEnd.aggregation &=
  attribute xmi.value { UML.AggregationKind }
AssociationEnd.targetScope =
  element UML:AssociationEnd.targetScope {
    attlist.AssociationEnd.targetScope, empty
  }
attlist.AssociationEnd.targetScope &=
  attribute xmi.value { UML.ScopeKind }
AssociationEnd.multiplicity =
  element UML:AssociationEnd.multiplicity {
    attlist.AssociationEnd.multiplicity, Multiplicity*
  }
attlist.AssociationEnd.multiplicity &= empty
AssociationEnd.changeability =
  element UML:AssociationEnd.changeability {
    attlist.AssociationEnd.changeability, empty
  }
attlist.AssociationEnd.changeability &=
  attribute xmi.value { UML.ChangeableKind }
AssociationEnd.association =
  element UML:AssociationEnd.association {
    attlist.AssociationEnd.association, Association*
  }
attlist.AssociationEnd.association &= empty
AssociationEnd.qualifier =
  element UML:AssociationEnd.qualifier {
    attlist.AssociationEnd.qualifier, Attribute*
  }
attlist.AssociationEnd.qualifier &= empty
AssociationEnd.participant =
  element UML:AssociationEnd.participant {
    attlist.AssociationEnd.participant, Classifier*
  }
attlist.AssociationEnd.participant &= empty
AssociationEnd.specification =
  element UML:AssociationEnd.specification {
    attlist.AssociationEnd.specification, Classifier*
  }
attlist.AssociationEnd.specification &= empty
UML.AssociationEndFeatures =
  UML.ModelElementFeatures
  | AssociationEnd.isNavigable
  | AssociationEnd.ordering
  | AssociationEnd.aggregation
  | AssociationEnd.targetScope
  | AssociationEnd.multiplicity
  | AssociationEnd.changeability
  | AssociationEnd.association
  | AssociationEnd.qualifier
  | AssociationEnd.participant
  | AssociationEnd.specification
UML.AssociationEndAtts =
  UML.ModelElementAtts,
  attribute isNavigable { "true" | "false" }?,
  attribute ordering { UML.OrderingKind }?,
  attribute aggregation { UML.AggregationKind }?,
  attribute targetScope { UML.ScopeKind }?,
  attribute changeability { UML.ChangeableKind }?,
  attribute association { xsd:IDREFS }?,
  attribute participant { xsd:IDREFS }?,
  attribute specification { xsd:IDREFS }?
AssociationEnd =
  element UML:AssociationEnd {
    attlist.AssociationEnd, UML.AssociationEndFeatures*
  }
attlist.AssociationEnd &= UML.AssociationEndAtts

# ========= UML:Association =========
# An association is a collection of two or more association ends (more
# is unusual).

Association.connection =
  element UML:Association.connection {
    attlist.Association.connection,
    (AssociationEnd | AssociationEndRole)*
  }
attlist.Association.connection &= empty
UML.AssociationFeatures =
  UML.GeneralizableElementFeatures | Association.connection
UML.AssociationAtts = UML.GeneralizableElementAtts
Association =
  element UML:Association {
    attlist.Association, UML.AssociationFeatures*
  }
attlist.Association &= UML.AssociationAtts


# ========= UML:Constraint =========

Constraint.body =
  element UML:Constraint.body {
    attlist.Constraint.body, BooleanExpression*
  }
attlist.Constraint.body &= empty
Constraint.constrainedElement =
  element UML:Constraint.constrainedElement {
    attlist.Constraint.constrainedElement, ModelElement*
  }
attlist.Constraint.constrainedElement &= empty
UML.ConstraintFeatures =
  UML.ModelElementFeatures
  | Constraint.body
  | Constraint.constrainedElement
UML.ConstraintAtts =
  UML.ModelElementAtts,
  attribute constrainedElement { xsd:IDREFS }?
Constraint =
  element UML:Constraint { attlist.Constraint, UML.ConstraintFeatures* }
attlist.Constraint &= UML.ConstraintAtts

# ========= UML:Relationship =========

UML.RelationshipFeatures = UML.ModelElementFeatures
UML.RelationshipAtts = UML.ModelElementAtts
Relationship =
  element UML:Relationship {
    attlist.Relationship, UML.RelationshipFeatures*
  }
attlist.Relationship &= UML.RelationshipAtts


# ========= UML:Generalization =========
Generalization.discriminator =
  element UML:Generalization.discriminator {
    attlist.Generalization.discriminator, (text | XMI.reference)*
  }
attlist.Generalization.discriminator &= empty
Generalization.child =
  element UML:Generalization.child {
    attlist.Generalization.child, GeneralizableElement*
  }
attlist.Generalization.child &= empty
Generalization.parent =
  element UML:Generalization.parent {
    attlist.Generalization.parent, GeneralizableElement*
  }
attlist.Generalization.parent &= empty
Generalization.powertype =
  element UML:Generalization.powertype {
    attlist.Generalization.powertype, Classifier*
  }
attlist.Generalization.powertype &= empty
UML.GeneralizationFeatures =
  UML.RelationshipFeatures
  | Generalization.discriminator
  | Generalization.child
  | Generalization.parent
  | Generalization.powertype
UML.GeneralizationAtts =
  UML.RelationshipAtts,
  attribute discriminator { text }?,
  attribute child { xsd:IDREFS }?,
  attribute parent { xsd:IDREFS }?,
  attribute powertype { xsd:IDREFS }?
Generalization =
  element UML:Generalization {
    attlist.Generalization, UML.GeneralizationFeatures*
  }
attlist.Generalization &= UML.GeneralizationAtts

# ========= UML:AssociationClass =========

UML.AssociationClassFeatures =
  UML.AssociationFeatures
  | Namespace.ownedElement
  | Classifier.feature
  | Classifier.powertypeRange
  | Class.isActive
UML.AssociationClassAtts =
  UML.AssociationAtts,
  attribute powertypeRange { xsd:IDREFS }?,
  attribute isActive { "true" | "false" }?
AssociationClass =
  element UML:AssociationClass {
    attlist.AssociationClass, UML.AssociationClassFeatures*
  }
attlist.AssociationClass &= UML.AssociationClassAtts

# ====================== Relationships & Dependencies ========================
# ========= UML:Dependency =========

Dependency.client =
  element UML:Dependency.client {
    attlist.Dependency.client, ModelElement*
  }
attlist.Dependency.client &= empty
Dependency.supplier =
  element UML:Dependency.supplier {
    attlist.Dependency.supplier, ModelElement*
  }
attlist.Dependency.supplier &= empty
UML.DependencyFeatures =
  UML.RelationshipFeatures | Dependency.client | Dependency.supplier
UML.DependencyAtts =
  UML.RelationshipAtts,
  attribute client { xsd:IDREFS }?,
  attribute supplier { xsd:IDREFS }?
Dependency =
  element UML:Dependency { attlist.Dependency, UML.DependencyFeatures* }
attlist.Dependency &= UML.DependencyAtts

# ========= UML:Abstraction =========

Abstraction.mapping =
  element UML:Abstraction.mapping {
    attlist.Abstraction.mapping, MappingExpression*
  }
attlist.Abstraction.mapping &= empty
UML.AbstractionFeatures = UML.DependencyFeatures | Abstraction.mapping
UML.AbstractionAtts = UML.DependencyAtts
Abstraction =
  element UML:Abstraction {
    attlist.Abstraction, UML.AbstractionFeatures*
  }
attlist.Abstraction &= UML.AbstractionAtts

# =========================== Other Diagrams ==================================
# ========= UML:PresentationElement =========

PresentationElement.subject =
  element UML:PresentationElement.subject {
    attlist.PresentationElement.subject, ModelElement*
  }
attlist.PresentationElement.subject &= empty
UML.PresentationElementFeatures =
  UML.ElementFeatures | PresentationElement.subject
UML.PresentationElementAtts =
  UML.ElementAtts,
  attribute subject { xsd:IDREFS }?
PresentationElement =
  element UML:PresentationElement {
    attlist.PresentationElement, UML.PresentationElementFeatures*
  }
attlist.PresentationElement &= UML.PresentationElementAtts

# ========= UML:Usage =========

UML.UsageFeatures = UML.DependencyFeatures
UML.UsageAtts = UML.DependencyAtts
Usage = element UML:Usage { attlist.Usage, UML.UsageFeatures* }
attlist.Usage &= UML.UsageAtts

# ========= UML:Binding =========

Binding.argument =
  element UML:Binding.argument {
    attlist.Binding.argument, TemplateArgument*
  }
attlist.Binding.argument &= empty
UML.BindingFeatures = UML.DependencyFeatures | Binding.argument
UML.BindingAtts = UML.DependencyAtts
Binding = element UML:Binding { attlist.Binding, UML.BindingFeatures* }
attlist.Binding &= UML.BindingAtts

# ========= UML:Component =========

Component.deploymentLocation =
  element UML:Component.deploymentLocation {
    attlist.Component.deploymentLocation, Node*
  }
attlist.Component.deploymentLocation &= empty
Component.residentElement =
  element UML:Component.residentElement {
    attlist.Component.residentElement, ElementResidence*
  }
attlist.Component.residentElement &= empty
Component.implementation =
  element UML:Component.implementation {
    attlist.Component.implementation, Artifact*
  }
attlist.Component.implementation &= empty
UML.ComponentFeatures =
  UML.ClassifierFeatures
  | Component.deploymentLocation
  | Component.residentElement
  | Component.implementation
UML.ComponentAtts =
  UML.ClassifierAtts,
  attribute deploymentLocation { xsd:IDREFS }?,
  attribute implementation { xsd:IDREFS }?
Component =
  element UML:Component { attlist.Component, UML.ComponentFeatures* }
attlist.Component &= UML.ComponentAtts

# ========= UML:Node =========

Node.deployedComponent =
  element UML:Node.deployedComponent {
    attlist.Node.deployedComponent, Component*
  }
attlist.Node.deployedComponent &= empty
UML.NodeFeatures = UML.ClassifierFeatures | Node.deployedComponent
UML.NodeAtts =
  UML.ClassifierAtts,
  attribute deployedComponent { xsd:IDREFS }?
Node = element UML:Node { attlist.Node, UML.NodeFeatures* }
attlist.Node &= UML.NodeAtts

# ========= UML:Permission =========

UML.PermissionFeatures = UML.DependencyFeatures
UML.PermissionAtts = UML.DependencyAtts
Permission =
  element UML:Permission { attlist.Permission, UML.PermissionFeatures* }
attlist.Permission &= UML.PermissionAtts

# ========= UML:Comment =========

Comment.body =
  element UML:Comment.body {
    attlist.Comment.body, (text | XMI.reference)*
  }
attlist.Comment.body &= empty
Comment.annotatedElement =
  element UML:Comment.annotatedElement {
    attlist.Comment.annotatedElement, ModelElement*
  }
attlist.Comment.annotatedElement &= empty
UML.CommentFeatures =
  UML.ModelElementFeatures | Comment.body | Comment.annotatedElement
UML.CommentAtts =
  UML.ModelElementAtts,
  attribute body { text }?,
  attribute annotatedElement { xsd:IDREFS }?
Comment = element UML:Comment { attlist.Comment, UML.CommentFeatures* }
attlist.Comment &= UML.CommentAtts

# ========= UML:Flow =========

Flow.target =
  element UML:Flow.target { attlist.Flow.target, ModelElement* }
attlist.Flow.target &= empty
Flow.source =
  element UML:Flow.source { attlist.Flow.source, ModelElement* }
attlist.Flow.source &= empty
UML.FlowFeatures = UML.RelationshipFeatures | Flow.target | Flow.source
UML.FlowAtts =
  UML.RelationshipAtts,
  attribute target { xsd:IDREFS }?,
  attribute source { xsd:IDREFS }?
Flow = element UML:Flow { attlist.Flow, UML.FlowFeatures* }
attlist.Flow &= UML.FlowAtts

# ========= UML:ElementResidence =========

ElementResidence.visibility =
  element UML:ElementResidence.visibility {
    attlist.ElementResidence.visibility, empty
  }
attlist.ElementResidence.visibility &=
  attribute xmi.value { UML.VisibilityKind }
ElementResidence.resident =
  element UML:ElementResidence.resident {
    attlist.ElementResidence.resident, ModelElement*
  }
attlist.ElementResidence.resident &= empty
ElementResidence.container =
  element UML:ElementResidence.container {
    attlist.ElementResidence.container, Component*
  }
attlist.ElementResidence.container &= empty
UML.ElementResidenceFeatures =
  XMI.extension
  | ElementResidence.visibility
  | ElementResidence.resident
  | ElementResidence.container
UML.ElementResidenceAtts =
  XMI.element.att,
  XMI.link.att,
  attribute visibility { UML.VisibilityKind }?,
  attribute resident { xsd:IDREFS }?,
  attribute container { xsd:IDREFS }?
ElementResidence =
  element UML:ElementResidence {
    attlist.ElementResidence, UML.ElementResidenceFeatures*
  }
attlist.ElementResidence &= UML.ElementResidenceAtts

# ========= UML:TemplateParameter =========

TemplateParameter.template =
  element UML:TemplateParameter.template {
    attlist.TemplateParameter.template, ModelElement*
  }
attlist.TemplateParameter.template &= empty
TemplateParameter.parameter =
  element UML:TemplateParameter.parameter {
    attlist.TemplateParameter.parameter,
    (ModelElement
     | Instance
     | Object
     | LinkObject
     | DataValue
     | ComponentInstance
     | NodeInstance
     | SubsystemInstance
     | UseCaseInstance
     | AttributeLink
     | Link
     | LinkEnd
     | Stimulus
     | Procedure
     | ExtensionPoint
     | StateMachine
     | ActivityGraph
     | Event
     | TimeEvent
     | CallEvent
     | SignalEvent
     | ChangeEvent
     | StateVertex
     | State
     | CompositeState
     | SubmachineState
     | SubactivityState
     | SimpleState
     | ActionState
     | CallState
     | ObjectFlowState
     | FinalState
     | Pseudostate
     | SynchState
     | StubState
     | Transition
     | Guard
     | Message
     | Interaction
     | InteractionInstanceSet
     | CollaborationInstanceSet
     | Partition
     | Variable
     | ArgumentSpecification
     | PrimitiveFunction
     | ControlFlow
     | Action
     | CollectionAction
     | FilterAction
     | IterateAction
     | MapAction
     | ReduceAction
     | ConditionalAction
     | GroupAction
     | LoopAction
     | HandlerAction
     | PrimitiveAction
     | ApplyFunctionAction
     | CodeAction
     | LiteralValueAction
     | MarshalAction
     | NullAction
     | TestIdentityAction
     | UnmarshalAction
     | JumpAction
     | InvocationAction
     | AsynchronousInvocationAction
     | SynchronousInvocationAction
     | ClearAssociationAction
     | LinkAction
     | ReadLinkAction
     | WriteLinkAction
     | CreateLinkAction
     | CreateLinkObjectAction
     | DestroyLinkAction
     | ReadLinkObjectEndAction
     | ReadLinkObjectQualifierAction
     | AttributeAction
     | ClearAttributeAction
     | ReadAttributeAction
     | WriteAttributeAction
     | AddAttributeValueAction
     | RemoveAttributeValueAction
     | CreateObjectAction
     | DestroyObjectAction
     | ReadIsClassifiedObjectAction
     | ReclassifyObjectAction
     | ReadExtentAction
     | ReadSelfAction
     | StartObjectStateMachineAction
     | VariableAction
     | ClearVariableAction
     | ReadVariableAction
     | WriteVariableAction
     | AddVariableValueAction
     | RemoveVariableValueAction
     | ExplicitInvocationActtion
     | CallOperationAction
     | SendSignalAction
     | BroadcastSignalAction
     | CallProcedureAction
     | DataFlow
     | Pin
     | InputPin
     | OutputPin
     | GeneralizableElement
     | Collaboration
     | Classifier
     | Signal
     | Exception
     | UseCase
     | Actor
     | ClassifierRole
     | ClassifierInState
     | Class
     | AssociationClass
     | DataType
     | Primitive
     | Enumeration
     | ProgrammingLanguageDataType
     | Interface
     | Component
     | Node
     | Artifact
     | Subsystem
     | Association
     | AssociationRole
     | Stereotype
     | Package
     | Model
     | Namespace
     | Feature
     | StructuralFeature
     | Attribute
     | BehavioralFeature
     | Reception
     | Operation
     | Method
     | AssociationEnd
     | AssociationEndRole
     | Constraint
     | Relationship
     | Extend
     | Include
     | Generalization
     | Dependency
     | Abstraction
     | Usage
     | Binding
     | Permission
     | Flow
     | Parameter
     | Comment
     | EnumerationLiteral
     | TagDefinition
     | TaggedValue)*
  }
attlist.TemplateParameter.parameter &= empty
TemplateParameter.defaultElement =
  element UML:TemplateParameter.defaultElement {
    attlist.TemplateParameter.defaultElement, ModelElement*
  }
attlist.TemplateParameter.defaultElement &= empty
UML.TemplateParameterFeatures =
  XMI.extension
  | TemplateParameter.template
  | TemplateParameter.parameter
  | TemplateParameter.defaultElement
UML.TemplateParameterAtts =
  XMI.element.att,
  XMI.link.att,
  attribute template { xsd:IDREFS }?,
  attribute defaultElement { xsd:IDREFS }?
TemplateParameter =
  element UML:TemplateParameter {
    attlist.TemplateParameter, UML.TemplateParameterFeatures*
  }
attlist.TemplateParameter &= UML.TemplateParameterAtts

# ========= UML:Stereotype =========

Stereotype.icon =
  element UML:Stereotype.icon {
    attlist.Stereotype.icon, (text | XMI.reference)*
  }
attlist.Stereotype.icon &= empty
Stereotype.baseClass =
  element UML:Stereotype.baseClass {
    attlist.Stereotype.baseClass, (text | XMI.reference)*
  }
attlist.Stereotype.baseClass &= empty
Stereotype.definedTag =
  element UML:Stereotype.definedTag {
    attlist.Stereotype.definedTag, TagDefinition*
  }
attlist.Stereotype.definedTag &= empty
Stereotype.stereotypeConstraint =
  element UML:Stereotype.stereotypeConstraint {
    attlist.Stereotype.stereotypeConstraint, Constraint*
  }
attlist.Stereotype.stereotypeConstraint &= empty
UML.StereotypeFeatures =
  UML.GeneralizableElementFeatures
  | Stereotype.icon
  | Stereotype.baseClass
  | Stereotype.definedTag
  | Stereotype.stereotypeConstraint
UML.StereotypeAtts =
  UML.GeneralizableElementAtts,
  attribute icon { text }?
Stereotype =
  element UML:Stereotype { attlist.Stereotype, UML.StereotypeFeatures* }
attlist.Stereotype &= UML.StereotypeAtts

# ========= UML:TagDefinition =========

TagDefinition.tagType =
  element UML:TagDefinition.tagType {
    attlist.TagDefinition.tagType, (text | XMI.reference)*
  }
attlist.TagDefinition.tagType &= empty
TagDefinition.multiplicity =
  element UML:TagDefinition.multiplicity {
    attlist.TagDefinition.multiplicity, Multiplicity*
  }
attlist.TagDefinition.multiplicity &= empty
TagDefinition.owner =
  element UML:TagDefinition.owner {
    attlist.TagDefinition.owner, Stereotype*
  }
attlist.TagDefinition.owner &= empty
UML.TagDefinitionFeatures =
  UML.ModelElementFeatures
  | TagDefinition.tagType
  | TagDefinition.multiplicity
  | TagDefinition.owner
UML.TagDefinitionAtts =
  UML.ModelElementAtts,
  attribute tagType { text }?,
  attribute owner { xsd:IDREFS }?
TagDefinition =
  element UML:TagDefinition {
    attlist.TagDefinition, UML.TagDefinitionFeatures*
  }
attlist.TagDefinition &= UML.TagDefinitionAtts

# ========= UML:TaggedValue =========

TaggedValue.dataValue =
  element UML:TaggedValue.dataValue {
    attlist.TaggedValue.dataValue, (text | XMI.reference)*
  }
attlist.TaggedValue.dataValue &= empty
TaggedValue.modelElement =
  element UML:TaggedValue.modelElement {
    attlist.TaggedValue.modelElement, ModelElement*
  }
attlist.TaggedValue.modelElement &= empty
TaggedValue.type =
  element UML:TaggedValue.type {
    attlist.TaggedValue.type, TagDefinition*
  }
attlist.TaggedValue.type &= empty
TaggedValue.referenceValue =
  element UML:TaggedValue.referenceValue {
    attlist.TaggedValue.referenceValue, ModelElement*
  }
attlist.TaggedValue.referenceValue &= empty
UML.TaggedValueFeatures =
  UML.ModelElementFeatures
  | TaggedValue.dataValue
  | TaggedValue.modelElement
  | TaggedValue.type
  | TaggedValue.referenceValue
UML.TaggedValueAtts =
  UML.ModelElementAtts,
  attribute modelElement { xsd:IDREFS }?,
  attribute type { xsd:IDREFS }?,
  attribute referenceValue { xsd:IDREFS }?
TaggedValue =
  element UML:TaggedValue {
    attlist.TaggedValue, UML.TaggedValueFeatures*
  }
attlist.TaggedValue &= UML.TaggedValueAtts

# ========= UML:ProgrammingLanguageDataType =========

ProgrammingLanguageDataType.expression =
  element UML:ProgrammingLanguageDataType.expression {
    attlist.ProgrammingLanguageDataType.expression, TypeExpression*
  }
attlist.ProgrammingLanguageDataType.expression &= empty
UML.ProgrammingLanguageDataTypeFeatures =
  UML.DataTypeFeatures | ProgrammingLanguageDataType.expression
UML.ProgrammingLanguageDataTypeAtts = UML.DataTypeAtts
ProgrammingLanguageDataType =
  element UML:ProgrammingLanguageDataType {
    attlist.ProgrammingLanguageDataType,
    UML.ProgrammingLanguageDataTypeFeatures*
  }
attlist.ProgrammingLanguageDataType &=
  UML.ProgrammingLanguageDataTypeAtts

# ========= UML:Artifact =========

UML.ArtifactFeatures = UML.ClassifierFeatures
UML.ArtifactAtts = UML.ClassifierAtts
Artifact =
  element UML:Artifact { attlist.Artifact, UML.ArtifactFeatures* }
attlist.Artifact &= UML.ArtifactAtts

# ========= UML:TemplateArgument =========

TemplateArgument.modelElement =
  element UML:TemplateArgument.modelElement {
    attlist.TemplateArgument.modelElement, ModelElement*
  }
attlist.TemplateArgument.modelElement &= empty
TemplateArgument.binding =
  element UML:TemplateArgument.binding {
    attlist.TemplateArgument.binding, Binding*
  }
attlist.TemplateArgument.binding &= empty
UML.TemplateArgumentFeatures =
  XMI.extension
  | TemplateArgument.modelElement
  | TemplateArgument.binding
UML.TemplateArgumentAtts =
  XMI.element.att,
  XMI.link.att,
  attribute modelElement { xsd:IDREFS }?,
  attribute binding { xsd:IDREFS }?
TemplateArgument =
  element UML:TemplateArgument {
    attlist.TemplateArgument, UML.TemplateArgumentFeatures*
  }
attlist.TemplateArgument &= UML.TemplateArgumentAtts

# ========= UML:Common_Behavior =========

# ========= UML:Instance =========
Instance.classifier =
  element UML:Instance.classifier {
    attlist.Instance.classifier, Classifier*
  }
attlist.Instance.classifier &= empty
Instance.linkEnd =
  element UML:Instance.linkEnd { attlist.Instance.linkEnd, LinkEnd* }
attlist.Instance.linkEnd &= empty
Instance.slot =
  element UML:Instance.slot { attlist.Instance.slot, AttributeLink* }
attlist.Instance.slot &= empty
Instance.componentInstance =
  element UML:Instance.componentInstance {
    attlist.Instance.componentInstance, ComponentInstance*
  }
attlist.Instance.componentInstance &= empty
Instance.ownedInstance =
  element UML:Instance.ownedInstance {
    attlist.Instance.ownedInstance,
    (Instance
     | Object
     | LinkObject
     | DataValue
     | ComponentInstance
     | NodeInstance
     | SubsystemInstance
     | UseCaseInstance)*
  }
attlist.Instance.ownedInstance &= empty
Instance.ownedLink =
  element UML:Instance.ownedLink {
    attlist.Instance.ownedLink, (Link | LinkObject)*
  }
attlist.Instance.ownedLink &= empty
UML.InstanceFeatures =
  UML.ModelElementFeatures
  | Instance.classifier
  | Instance.linkEnd
  | Instance.slot
  | Instance.componentInstance
  | Instance.ownedInstance
  | Instance.ownedLink
UML.InstanceAtts =
  UML.ModelElementAtts,
  attribute classifier { xsd:IDREFS }?,
  attribute linkEnd { xsd:IDREFS }?,
  attribute componentInstance { xsd:IDREFS }?
Instance =
  element UML:Instance { attlist.Instance, UML.InstanceFeatures* }
attlist.Instance &= UML.InstanceAtts

# ========= UML:Signal =========

UML.SignalFeatures = UML.ClassifierFeatures
UML.SignalAtts = UML.ClassifierAtts
Signal = element UML:Signal { attlist.Signal, UML.SignalFeatures* }
attlist.Signal &= UML.SignalAtts

# ========= UML:UninterpretedAction =========

UML.UninterpretedActionFeatures = XMI.extension
UML.UninterpretedActionAtts = XMI.element.att, XMI.link.att
UninterpretedAction =
  element UML:UninterpretedAction {
    attlist.UninterpretedAction, UML.UninterpretedActionFeatures*
  }
attlist.UninterpretedAction &= UML.UninterpretedActionAtts

# ========= UML:AttributeLink =========

AttributeLink.attribute =
  element UML:AttributeLink.attribute {
    attlist.AttributeLink.attribute, Attribute*
  }
attlist.AttributeLink.attribute &= empty
AttributeLink.value =
  element UML:AttributeLink.value {
    attlist.AttributeLink.value, Instance*
  }
attlist.AttributeLink.value &= empty
AttributeLink.instance =
  element UML:AttributeLink.instance {
    attlist.AttributeLink.instance, Instance*
  }
attlist.AttributeLink.instance &= empty
AttributeLink.linkEnd =
  element UML:AttributeLink.linkEnd {
    attlist.AttributeLink.linkEnd, LinkEnd*
  }
attlist.AttributeLink.linkEnd &= empty
UML.AttributeLinkFeatures =
  UML.ModelElementFeatures
  | AttributeLink.attribute
  | AttributeLink.value
  | AttributeLink.instance
  | AttributeLink.linkEnd
UML.AttributeLinkAtts =
  UML.ModelElementAtts,
  attribute attribute { xsd:IDREFS }?,
  attribute value { xsd:IDREFS }?,
  attribute instance { xsd:IDREFS }?,
  attribute linkEnd { xsd:IDREFS }?
AttributeLink =
  element UML:AttributeLink {
    attlist.AttributeLink, UML.AttributeLinkFeatures*
  }
attlist.AttributeLink &= UML.AttributeLinkAtts

# ========= UML:Object =========

UML.ObjectFeatures = UML.InstanceFeatures
UML.ObjectAtts = UML.InstanceAtts
Object = element UML:Object { attlist.Object, UML.ObjectFeatures* }
attlist.Object &= UML.ObjectAtts

# ========= UML:Link =========

Link.association =
  element UML:Link.association {
    attlist.Link.association, Association*
  }
attlist.Link.association &= empty
Link.connection =
  element UML:Link.connection { attlist.Link.connection, LinkEnd* }
attlist.Link.connection &= empty
UML.LinkFeatures =
  UML.ModelElementFeatures | Link.association | Link.connection
UML.LinkAtts =
  UML.ModelElementAtts,
  attribute association { xsd:IDREFS }?
Link = element UML:Link { attlist.Link, UML.LinkFeatures* }
attlist.Link &= UML.LinkAtts

# ========= UML:LinkObject =========

UML.LinkObjectFeatures =
  UML.ObjectFeatures | Link.association | Link.connection
UML.LinkObjectAtts =
  UML.ObjectAtts,
  attribute association { xsd:IDREFS }?
LinkObject =
  element UML:LinkObject { attlist.LinkObject, UML.LinkObjectFeatures* }
attlist.LinkObject &= UML.LinkObjectAtts

# ========= UML:DataValue =========

UML.DataValueFeatures = UML.InstanceFeatures
UML.DataValueAtts = UML.InstanceAtts
DataValue =
  element UML:DataValue { attlist.DataValue, UML.DataValueFeatures* }
attlist.DataValue &= UML.DataValueAtts

# ========= UML:Reception =========

Reception.specification =
  element UML:Reception.specification {
    attlist.Reception.specification, (text | XMI.reference)*
  }
attlist.Reception.specification &= empty
Reception.isRoot =
  element UML:Reception.isRoot { attlist.Reception.isRoot, empty }
attlist.Reception.isRoot &= attribute xmi.value { "true" | "false" }
Reception.isLeaf =
  element UML:Reception.isLeaf { attlist.Reception.isLeaf, empty }
attlist.Reception.isLeaf &= attribute xmi.value { "true" | "false" }
Reception.isAbstract =
  element UML:Reception.isAbstract {
    attlist.Reception.isAbstract, empty
  }
attlist.Reception.isAbstract &= attribute xmi.value { "true" | "false" }
Reception.signal =
  element UML:Reception.signal { attlist.Reception.signal, Signal* }
attlist.Reception.signal &= empty
UML.ReceptionFeatures =
  UML.BehavioralFeatureFeatures
  | Reception.specification
  | Reception.isRoot
  | Reception.isLeaf
  | Reception.isAbstract
  | Reception.signal
UML.ReceptionAtts =
  UML.BehavioralFeatureAtts,
  attribute specification { text }?,
  attribute isRoot { "true" | "false" }?,
  attribute isLeaf { "true" | "false" }?,
  attribute isAbstract { "true" | "false" }?,
  attribute signal { xsd:IDREFS }?
Reception =
  element UML:Reception { attlist.Reception, UML.ReceptionFeatures* }
attlist.Reception &= UML.ReceptionAtts

# ========= UML:LinkEnd =========

LinkEnd.instance =
  element UML:LinkEnd.instance { attlist.LinkEnd.instance, Instance* }
attlist.LinkEnd.instance &= empty
LinkEnd.link = element UML:LinkEnd.link { attlist.LinkEnd.link, Link* }
attlist.LinkEnd.link &= empty
LinkEnd.associationEnd =
  element UML:LinkEnd.associationEnd {
    attlist.LinkEnd.associationEnd, AssociationEnd*
  }
attlist.LinkEnd.associationEnd &= empty
LinkEnd.qualifiedValue =
  element UML:LinkEnd.qualifiedValue {
    attlist.LinkEnd.qualifiedValue, AttributeLink*
  }
attlist.LinkEnd.qualifiedValue &= empty
UML.LinkEndFeatures =
  UML.ModelElementFeatures
  | LinkEnd.instance
  | LinkEnd.link
  | LinkEnd.associationEnd
  | LinkEnd.qualifiedValue
UML.LinkEndAtts =
  UML.ModelElementAtts,
  attribute instance { xsd:IDREFS }?,
  attribute link { xsd:IDREFS }?,
  attribute associationEnd { xsd:IDREFS }?
LinkEnd = element UML:LinkEnd { attlist.LinkEnd, UML.LinkEndFeatures* }
attlist.LinkEnd &= UML.LinkEndAtts

# ========= UML:TerminateAction =========

UML.TerminateActionFeatures = XMI.extension
UML.TerminateActionAtts = XMI.element.att, XMI.link.att
TerminateAction =
  element UML:TerminateAction {
    attlist.TerminateAction, UML.TerminateActionFeatures*
  }
attlist.TerminateAction &= UML.TerminateActionAtts

# ========= UML:Stimulus =========

Stimulus.argument =
  element UML:Stimulus.argument { attlist.Stimulus.argument, Instance* }
attlist.Stimulus.argument &= empty
Stimulus.sender =
  element UML:Stimulus.sender { attlist.Stimulus.sender, Instance* }
attlist.Stimulus.sender &= empty
Stimulus.receiver =
  element UML:Stimulus.receiver { attlist.Stimulus.receiver, Instance* }
attlist.Stimulus.receiver &= empty
Stimulus.communicationLink =
  element UML:Stimulus.communicationLink {
    attlist.Stimulus.communicationLink, Link*
  }
attlist.Stimulus.communicationLink &= empty
Stimulus.dispatchAction =
  element UML:Stimulus.dispatchAction {
    attlist.Stimulus.dispatchAction, Procedure*
  }
attlist.Stimulus.dispatchAction &= empty
UML.StimulusFeatures =
  UML.ModelElementFeatures
  | Stimulus.argument
  | Stimulus.sender
  | Stimulus.receiver
  | Stimulus.communicationLink
  | Stimulus.dispatchAction
UML.StimulusAtts =
  UML.ModelElementAtts,
  attribute argument { xsd:IDREFS }?,
  attribute sender { xsd:IDREFS }?,
  attribute receiver { xsd:IDREFS }?,
  attribute communicationLink { xsd:IDREFS }?,
  attribute dispatchAction { xsd:IDREFS }?
Stimulus =
  element UML:Stimulus { attlist.Stimulus, UML.StimulusFeatures* }
attlist.Stimulus &= UML.StimulusAtts

# ========= UML:Exception =========

UML.ExceptionFeatures = UML.SignalFeatures
UML.ExceptionAtts = UML.SignalAtts
Exception =
  element UML:Exception { attlist.Exception, UML.ExceptionFeatures* }
attlist.Exception &= UML.ExceptionAtts

# ========= UML:ComponentInstance =========

ComponentInstance.nodeInstance =
  element UML:ComponentInstance.nodeInstance {
    attlist.ComponentInstance.nodeInstance, NodeInstance*
  }
attlist.ComponentInstance.nodeInstance &= empty
ComponentInstance.resident =
  element UML:ComponentInstance.resident {
    attlist.ComponentInstance.resident, Instance*
  }
attlist.ComponentInstance.resident &= empty
UML.ComponentInstanceFeatures =
  UML.InstanceFeatures
  | ComponentInstance.nodeInstance
  | ComponentInstance.resident
UML.ComponentInstanceAtts =
  UML.InstanceAtts,
  attribute nodeInstance { xsd:IDREFS }?,
  attribute resident { xsd:IDREFS }?
ComponentInstance =
  element UML:ComponentInstance {
    attlist.ComponentInstance, UML.ComponentInstanceFeatures*
  }
attlist.ComponentInstance &= UML.ComponentInstanceAtts

# ========= UML:NodeInstance =========

NodeInstance.resident =
  element UML:NodeInstance.resident {
    attlist.NodeInstance.resident, ComponentInstance*
  }
attlist.NodeInstance.resident &= empty
UML.NodeInstanceFeatures = UML.InstanceFeatures | NodeInstance.resident
UML.NodeInstanceAtts =
  UML.InstanceAtts,
  attribute resident { xsd:IDREFS }?
NodeInstance =
  element UML:NodeInstance {
    attlist.NodeInstance, UML.NodeInstanceFeatures*
  }
attlist.NodeInstance &= UML.NodeInstanceAtts

# ========= UML:SubsystemInstance =========

UML.SubsystemInstanceFeatures = UML.InstanceFeatures
UML.SubsystemInstanceAtts = UML.InstanceAtts
SubsystemInstance =
  element UML:SubsystemInstance {
    attlist.SubsystemInstance, UML.SubsystemInstanceFeatures*
  }
attlist.SubsystemInstance &= UML.SubsystemInstanceAtts

# ========= UML:Procedure =========

Procedure.language =
  element UML:Procedure.language {
    attlist.Procedure.language, (text | XMI.reference)*
  }
attlist.Procedure.language &= empty
Procedure.body =
  element UML:Procedure.body {
    attlist.Procedure.body, (text | XMI.reference)*
  }
attlist.Procedure.body &= empty
Procedure.isList =
  element UML:Procedure.isList { attlist.Procedure.isList, empty }
attlist.Procedure.isList &= attribute xmi.value { "true" | "false" }
Procedure.expression =
  element UML:Procedure.expression {
    attlist.Procedure.expression, Expression*
  }
attlist.Procedure.expression &= empty
Procedure.method =
  element UML:Procedure.method { attlist.Procedure.method, Method* }
attlist.Procedure.method &= empty
UML.ProcedureFeatures =
  UML.ModelElementFeatures
  | Procedure.language
  | Procedure.body
  | Procedure.isList
  | Procedure.expression
  | Procedure.method
UML.ProcedureAtts =
  UML.ModelElementAtts,
  attribute language { text }?,
  attribute body { text }?,
  attribute isList { "true" | "false" }?,
  attribute expression { xsd:IDREFS }?,
  attribute method { xsd:IDREFS }?
Procedure =
  element UML:Procedure { attlist.Procedure, UML.ProcedureFeatures* }
attlist.Procedure &= UML.ProcedureAtts

# ========= UML:A_context_raisedSignal =========

A_context_raisedSignal.context =
  element UML:A_context_raisedSignal.context {
    attlist.A_context_raisedSignal.context, BehavioralFeature?
  }
attlist.A_context_raisedSignal.context &= empty
A_context_raisedSignal.raisedSignal =
  element UML:A_context_raisedSignal.raisedSignal {
    attlist.A_context_raisedSignal.raisedSignal, Signal?
  }
attlist.A_context_raisedSignal.raisedSignal &= empty
A_context_raisedSignal =
  element UML:A_context_raisedSignal {
    attlist.A_context_raisedSignal,
    (A_context_raisedSignal.context
     | A_context_raisedSignal.raisedSignal)*
  }
attlist.A_context_raisedSignal &=
  XMI.element.att,
  XMI.link.att,
  attribute context { xsd:IDREFS }?,
  attribute raisedSignal { xsd:IDREFS }?


# ========= UML:Action_Foundation =========

# ========= UML:ControlFlow =========

ControlFlow.predecessor =
  element UML:ControlFlow.predecessor {
    attlist.ControlFlow.predecessor, Action*
  }
attlist.ControlFlow.predecessor &= empty
ControlFlow.successor =
  element UML:ControlFlow.successor {
    attlist.ControlFlow.successor, Action*
  }
attlist.ControlFlow.successor &= empty
UML.ControlFlowFeatures =
  UML.ModelElementFeatures
  | ControlFlow.predecessor
  | ControlFlow.successor
UML.ControlFlowAtts =
  UML.ModelElementAtts,
  attribute predecessor { xsd:IDREFS }?,
  attribute successor { xsd:IDREFS }?
ControlFlow =
  element UML:ControlFlow {
    attlist.ControlFlow, UML.ControlFlowFeatures*
  }
attlist.ControlFlow &= UML.ControlFlowAtts

# ========= UML:Action =========

Action.isReadOnly =
  element UML:Action.isReadOnly { attlist.Action.isReadOnly, empty }
attlist.Action.isReadOnly &= attribute xmi.value { "true" | "false" }
Action.consequent =
  element UML:Action.consequent {
    attlist.Action.consequent, ControlFlow*
  }
attlist.Action.consequent &= empty
Action.antecedent =
  element UML:Action.antecedent {
    attlist.Action.antecedent, ControlFlow*
  }
attlist.Action.antecedent &= empty
Action.outputPin =
  element UML:Action.outputPin { attlist.Action.outputPin, OutputPin* }
attlist.Action.outputPin &= empty
Action.inputPin =
  element UML:Action.inputPin { attlist.Action.inputPin, InputPin* }
attlist.Action.inputPin &= empty
Action.procedure =
  element UML:Action.procedure { attlist.Action.procedure, Procedure* }
attlist.Action.procedure &= empty
UML.ActionFeatures =
  UML.ModelElementFeatures
  | Action.isReadOnly
  | Action.consequent
  | Action.antecedent
  | Action.outputPin
  | Action.inputPin
  | Action.procedure
UML.ActionAtts =
  UML.ModelElementAtts,
  attribute isReadOnly { "true" | "false" }?,
  attribute consequent { xsd:IDREFS }?,
  attribute antecedent { xsd:IDREFS }?,
  attribute procedure { xsd:IDREFS }?
Action = element UML:Action { attlist.Action, UML.ActionFeatures* }
attlist.Action &= UML.ActionAtts

# ========= UML:PrimitiveAction =========

UML.PrimitiveActionFeatures = UML.ActionFeatures
UML.PrimitiveActionAtts = UML.ActionAtts
PrimitiveAction =
  element UML:PrimitiveAction {
    attlist.PrimitiveAction, UML.PrimitiveActionFeatures*
  }
attlist.PrimitiveAction &= UML.PrimitiveActionAtts

# ========= UML:Pin =========

Pin.multiplicity =
  element UML:Pin.multiplicity {
    attlist.Pin.multiplicity, Multiplicity*
  }
attlist.Pin.multiplicity &= empty
Pin.ordering = element UML:Pin.ordering { attlist.Pin.ordering, empty }
attlist.Pin.ordering &= attribute xmi.value { UML.OrderingKind }
Pin.type = element UML:Pin.type { attlist.Pin.type, Classifier* }
attlist.Pin.type &= empty
UML.PinFeatures =
  UML.ModelElementFeatures | Pin.multiplicity | Pin.ordering | Pin.type
UML.PinAtts =
  UML.ModelElementAtts,
  attribute ordering { UML.OrderingKind }?,
  attribute type { xsd:IDREFS }?
Pin = element UML:Pin { attlist.Pin, UML.PinFeatures* }
attlist.Pin &= UML.PinAtts

# ========= UML:InputPin =========

InputPin.flow =
  element UML:InputPin.flow { attlist.InputPin.flow, DataFlow* }
attlist.InputPin.flow &= empty
InputPin.procedure =
  element UML:InputPin.procedure {
    attlist.InputPin.procedure, Procedure*
  }
attlist.InputPin.procedure &= empty
InputPin.action =
  element UML:InputPin.action { attlist.InputPin.action, Action* }
attlist.InputPin.action &= empty
UML.InputPinFeatures =
  UML.PinFeatures | InputPin.flow | InputPin.procedure | InputPin.action
UML.InputPinAtts =
  UML.PinAtts,
  attribute flow { xsd:IDREFS }?,
  attribute procedure { xsd:IDREFS }?,
  attribute action { xsd:IDREFS }?
InputPin =
  element UML:InputPin { attlist.InputPin, UML.InputPinFeatures* }
attlist.InputPin &= UML.InputPinAtts

# ========= UML:DataFlow =========

DataFlow.source =
  element UML:DataFlow.source { attlist.DataFlow.source, OutputPin* }
attlist.DataFlow.source &= empty
DataFlow.destination =
  element UML:DataFlow.destination {
    attlist.DataFlow.destination, InputPin*
  }
attlist.DataFlow.destination &= empty
UML.DataFlowFeatures =
  UML.ModelElementFeatures | DataFlow.source | DataFlow.destination
UML.DataFlowAtts =
  UML.ModelElementAtts,
  attribute source { xsd:IDREFS }?,
  attribute destination { xsd:IDREFS }?
DataFlow =
  element UML:DataFlow { attlist.DataFlow, UML.DataFlowFeatures* }
attlist.DataFlow &= UML.DataFlowAtts

# ========= UML:OutputPin =========

OutputPin.flow =
  element UML:OutputPin.flow { attlist.OutputPin.flow, DataFlow* }
attlist.OutputPin.flow &= empty
OutputPin.procedure =
  element UML:OutputPin.procedure {
    attlist.OutputPin.procedure, Procedure*
  }
attlist.OutputPin.procedure &= empty
OutputPin.action =
  element UML:OutputPin.action { attlist.OutputPin.action, Action* }
attlist.OutputPin.action &= empty
UML.OutputPinFeatures =
  UML.PinFeatures
  | OutputPin.flow
  | OutputPin.procedure
  | OutputPin.action
UML.OutputPinAtts =
  UML.PinAtts,
  attribute flow { xsd:IDREFS }?,
  attribute procedure { xsd:IDREFS }?,
  attribute action { xsd:IDREFS }?
OutputPin =
  element UML:OutputPin { attlist.OutputPin, UML.OutputPinFeatures* }
attlist.OutputPin &= UML.OutputPinAtts


# ========= UML:Actions =========

# ========= UML:CollectionAction =========

CollectionAction.subaction =
  element UML:CollectionAction.subaction {
    attlist.CollectionAction.subaction, Action*
  }
attlist.CollectionAction.subaction &= empty
UML.CollectionActionFeatures =
  UML.ActionFeatures | CollectionAction.subaction
UML.CollectionActionAtts =
  UML.ActionAtts,
  attribute subaction { xsd:IDREFS }?
CollectionAction =
  element UML:CollectionAction {
    attlist.CollectionAction, UML.CollectionActionFeatures*
  }
attlist.CollectionAction &= UML.CollectionActionAtts

# ========= UML:FilterAction =========

FilterAction.subinput =
  element UML:FilterAction.subinput {
    attlist.FilterAction.subinput, OutputPin*
  }
attlist.FilterAction.subinput &= empty
FilterAction.subtest =
  element UML:FilterAction.subtest {
    attlist.FilterAction.subtest, OutputPin*
  }
attlist.FilterAction.subtest &= empty
UML.FilterActionFeatures =
  UML.CollectionActionFeatures
  | FilterAction.subinput
  | FilterAction.subtest
UML.FilterActionAtts =
  UML.CollectionActionAtts,
  attribute subtest { xsd:IDREFS }?
FilterAction =
  element UML:FilterAction {
    attlist.FilterAction, UML.FilterActionFeatures*
  }
attlist.FilterAction &= UML.FilterActionAtts

# ========= UML:IterateAction =========

IterateAction.subinput =
  element UML:IterateAction.subinput {
    attlist.IterateAction.subinput, OutputPin*
  }
attlist.IterateAction.subinput &= empty
IterateAction.loopVariable =
  element UML:IterateAction.loopVariable {
    attlist.IterateAction.loopVariable, OutputPin*
  }
attlist.IterateAction.loopVariable &= empty
IterateAction.suboutput =
  element UML:IterateAction.suboutput {
    attlist.IterateAction.suboutput, OutputPin*
  }
attlist.IterateAction.suboutput &= empty
IterateAction.isUnordered =
  element UML:IterateAction.isUnordered {
    attlist.IterateAction.isUnordered, empty
  }
attlist.IterateAction.isUnordered &=
  attribute xmi.value { "true" | "false" }
UML.IterateActionFeatures =
  UML.CollectionActionFeatures
  | IterateAction.subinput
  | IterateAction.loopVariable
  | IterateAction.suboutput
  | IterateAction.isUnordered
UML.IterateActionAtts =
  UML.CollectionActionAtts,
  attribute subinput { xsd:IDREFS }?,
  attribute suboutput { xsd:IDREFS }?,
  attribute isUnordered { "true" | "false" }?
IterateAction =
  element UML:IterateAction {
    attlist.IterateAction, UML.IterateActionFeatures*
  }
attlist.IterateAction &= UML.IterateActionAtts

# ========= UML:MapAction =========

MapAction.subinput =
  element UML:MapAction.subinput {
    attlist.MapAction.subinput, OutputPin*
  }
attlist.MapAction.subinput &= empty
MapAction.suboutput =
  element UML:MapAction.suboutput {
    attlist.MapAction.suboutput, OutputPin*
  }
attlist.MapAction.suboutput &= empty
UML.MapActionFeatures =
  UML.CollectionActionFeatures
  | MapAction.subinput
  | MapAction.suboutput
UML.MapActionAtts =
  UML.CollectionActionAtts,
  attribute suboutput { xsd:IDREFS }?
MapAction =
  element UML:MapAction { attlist.MapAction, UML.MapActionFeatures* }
attlist.MapAction &= UML.MapActionAtts
# ========= UML:ReduceAction =========
ReduceAction.leftSubinput =
  element UML:ReduceAction.leftSubinput {
    attlist.ReduceAction.leftSubinput, OutputPin*
  }
attlist.ReduceAction.leftSubinput &= empty
ReduceAction.suboutput =
  element UML:ReduceAction.suboutput {
    attlist.ReduceAction.suboutput, OutputPin*
  }
attlist.ReduceAction.suboutput &= empty
ReduceAction.rightSubinput =
  element UML:ReduceAction.rightSubinput {
    attlist.ReduceAction.rightSubinput, OutputPin*
  }
attlist.ReduceAction.rightSubinput &= empty
ReduceAction.isUnordered =
  element UML:ReduceAction.isUnordered {
    attlist.ReduceAction.isUnordered, empty
  }
attlist.ReduceAction.isUnordered &=
  attribute xmi.value { "true" | "false" }
UML.ReduceActionFeatures =
  UML.CollectionActionFeatures
  | ReduceAction.leftSubinput
  | ReduceAction.suboutput
  | ReduceAction.rightSubinput
  | ReduceAction.isUnordered
UML.ReduceActionAtts =
  UML.CollectionActionAtts,
  attribute suboutput { xsd:IDREFS }?,
  attribute isUnordered { "true" | "false" }?
ReduceAction =
  element UML:ReduceAction {
    attlist.ReduceAction, UML.ReduceActionFeatures*
  }
attlist.ReduceAction &= UML.ReduceActionAtts

# ========= UML:Clause =========

Clause.body =
  element UML:Clause.body {
    attlist.Clause.body,
    (Action
     | CollectionAction
     | FilterAction
     | IterateAction
     | MapAction
     | ReduceAction
     | ConditionalAction
     | GroupAction
     | LoopAction
     | HandlerAction
     | PrimitiveAction
     | ApplyFunctionAction
     | CodeAction
     | LiteralValueAction
     | MarshalAction
     | NullAction
     | TestIdentityAction
     | UnmarshalAction
     | JumpAction
     | InvocationAction
     | AsynchronousInvocationAction
     | SynchronousInvocationAction
     | ClearAssociationAction
     | LinkAction
     | ReadLinkAction
     | WriteLinkAction
     | CreateLinkAction
     | CreateLinkObjectAction
     | DestroyLinkAction
     | ReadLinkObjectEndAction
     | ReadLinkObjectQualifierAction
     | AttributeAction
     | ClearAttributeAction
     | ReadAttributeAction
     | WriteAttributeAction
     | AddAttributeValueAction
     | RemoveAttributeValueAction
     | CreateObjectAction
     | DestroyObjectAction
     | ReadIsClassifiedObjectAction
     | ReclassifyObjectAction
     | ReadExtentAction
     | ReadSelfAction
     | StartObjectStateMachineAction
     | VariableAction
     | ClearVariableAction
     | ReadVariableAction
     | WriteVariableAction
     | AddVariableValueAction
     | RemoveVariableValueAction
     | ExplicitInvocationActtion
     | CallOperationAction
     | SendSignalAction
     | BroadcastSignalAction
     | CallProcedureAction)*
  }
attlist.Clause.body &= empty
Clause.test =
  element UML:Clause.test {
    attlist.Clause.test,
    (Action
     | CollectionAction
     | FilterAction
     | IterateAction
     | MapAction
     | ReduceAction
     | ConditionalAction
     | GroupAction
     | LoopAction
     | HandlerAction
     | PrimitiveAction
     | ApplyFunctionAction
     | CodeAction
     | LiteralValueAction
     | MarshalAction
     | NullAction
     | TestIdentityAction
     | UnmarshalAction
     | JumpAction
     | InvocationAction
     | AsynchronousInvocationAction
     | SynchronousInvocationAction
     | ClearAssociationAction
     | LinkAction
     | ReadLinkAction
     | WriteLinkAction
     | CreateLinkAction
     | CreateLinkObjectAction
     | DestroyLinkAction
     | ReadLinkObjectEndAction
     | ReadLinkObjectQualifierAction
     | AttributeAction
     | ClearAttributeAction
     | ReadAttributeAction
     | WriteAttributeAction
     | AddAttributeValueAction
     | RemoveAttributeValueAction
     | CreateObjectAction
     | DestroyObjectAction
     | ReadIsClassifiedObjectAction
     | ReclassifyObjectAction
     | ReadExtentAction
     | ReadSelfAction
     | StartObjectStateMachineAction
     | VariableAction
     | ClearVariableAction
     | ReadVariableAction
     | WriteVariableAction
     | AddVariableValueAction
     | RemoveVariableValueAction
     | ExplicitInvocationActtion
     | CallOperationAction
     | SendSignalAction
     | BroadcastSignalAction
     | CallProcedureAction)*
  }
attlist.Clause.test &= empty
Clause.bodyOutput =
  element UML:Clause.bodyOutput {
    attlist.Clause.bodyOutput, OutputPin*
  }
attlist.Clause.bodyOutput &= empty
Clause.testOutput =
  element UML:Clause.testOutput {
    attlist.Clause.testOutput, OutputPin*
  }
attlist.Clause.testOutput &= empty
Clause.successorClause =
  element UML:Clause.successorClause {
    attlist.Clause.successorClause, Clause*
  }
attlist.Clause.successorClause &= empty
Clause.predecessorClause =
  element UML:Clause.predecessorClause {
    attlist.Clause.predecessorClause, Clause*
  }
attlist.Clause.predecessorClause &= empty
UML.ClauseFeatures =
  UML.ElementFeatures
  | Clause.body
  | Clause.test
  | Clause.bodyOutput
  | Clause.testOutput
  | Clause.successorClause
  | Clause.predecessorClause
UML.ClauseAtts =
  UML.ElementAtts,
  attribute bodyOutput { xsd:IDREFS }?,
  attribute testOutput { xsd:IDREFS }?,
  attribute successorClause { xsd:IDREFS }?,
  attribute predecessorClause { xsd:IDREFS }?
Clause = element UML:Clause { attlist.Clause, UML.ClauseFeatures* }
attlist.Clause &= UML.ClauseAtts

# ========= UML:ConditionalAction =========

ConditionalAction.clause =
  element UML:ConditionalAction.clause {
    attlist.ConditionalAction.clause, Clause*
  }
attlist.ConditionalAction.clause &= empty
ConditionalAction.isDeterminate =
  element UML:ConditionalAction.isDeterminate {
    attlist.ConditionalAction.isDeterminate, empty
  }
attlist.ConditionalAction.isDeterminate &=
  attribute xmi.value { "true" | "false" }
UML.ConditionalActionFeatures =
  UML.ActionFeatures
  | ConditionalAction.clause
  | ConditionalAction.isDeterminate
UML.ConditionalActionAtts =
  UML.ActionAtts,
  attribute isDeterminate { "true" | "false" }?
ConditionalAction =
  element UML:ConditionalAction {
    attlist.ConditionalAction, UML.ConditionalActionFeatures*
  }
attlist.ConditionalAction &= UML.ConditionalActionAtts

# ========= UML:GroupAction =========

GroupAction.subaction =
  element UML:GroupAction.subaction {
    attlist.GroupAction.subaction,
    (Action
     | CollectionAction
     | FilterAction
     | IterateAction
     | MapAction
     | ReduceAction
     | ConditionalAction
     | GroupAction
     | LoopAction
     | HandlerAction
     | PrimitiveAction
     | ApplyFunctionAction
     | CodeAction
     | LiteralValueAction
     | MarshalAction
     | NullAction
     | TestIdentityAction
     | UnmarshalAction
     | JumpAction
     | InvocationAction
     | AsynchronousInvocationAction
     | SynchronousInvocationAction
     | ClearAssociationAction
     | LinkAction
     | ReadLinkAction
     | WriteLinkAction
     | CreateLinkAction
     | CreateLinkObjectAction
     | DestroyLinkAction
     | ReadLinkObjectEndAction
     | ReadLinkObjectQualifierAction
     | AttributeAction
     | ClearAttributeAction
     | ReadAttributeAction
     | WriteAttributeAction
     | AddAttributeValueAction
     | RemoveAttributeValueAction
     | CreateObjectAction
     | DestroyObjectAction
     | ReadIsClassifiedObjectAction
     | ReclassifyObjectAction
     | ReadExtentAction
     | ReadSelfAction
     | StartObjectStateMachineAction
     | VariableAction
     | ClearVariableAction
     | ReadVariableAction
     | WriteVariableAction
     | AddVariableValueAction
     | RemoveVariableValueAction
     | ExplicitInvocationActtion
     | CallOperationAction
     | SendSignalAction
     | BroadcastSignalAction
     | CallProcedureAction)*
  }
attlist.GroupAction.subaction &= empty
GroupAction.variable =
  element UML:GroupAction.variable {
    attlist.GroupAction.variable, Variable*
  }
attlist.GroupAction.variable &= empty
GroupAction.mustIsolate =
  element UML:GroupAction.mustIsolate {
    attlist.GroupAction.mustIsolate, empty
  }
attlist.GroupAction.mustIsolate &=
  attribute xmi.value { "true" | "false" }
UML.GroupActionFeatures =
  UML.ActionFeatures
  | GroupAction.subaction
  | GroupAction.variable
  | GroupAction.mustIsolate
UML.GroupActionAtts =
  UML.ActionAtts,
  attribute mustIsolate { "true" | "false" }?
GroupAction =
  element UML:GroupAction {
    attlist.GroupAction, UML.GroupActionFeatures*
  }
attlist.GroupAction &= UML.GroupActionAtts

# ========= UML:LoopAction =========

LoopAction.clause =
  element UML:LoopAction.clause { attlist.LoopAction.clause, Clause* }
attlist.LoopAction.clause &= empty
LoopAction.loopVariable =
  element UML:LoopAction.loopVariable {
    attlist.LoopAction.loopVariable, OutputPin*
  }
attlist.LoopAction.loopVariable &= empty
UML.LoopActionFeatures =
  UML.ActionFeatures | LoopAction.clause | LoopAction.loopVariable
UML.LoopActionAtts = UML.ActionAtts
LoopAction =
  element UML:LoopAction { attlist.LoopAction, UML.LoopActionFeatures* }
attlist.LoopAction &= UML.LoopActionAtts

# ========= UML:Variable =========

Variable.type =
  element UML:Variable.type { attlist.Variable.type, Classifier* }
attlist.Variable.type &= empty
Variable.scope =
  element UML:Variable.scope { attlist.Variable.scope, GroupAction* }
attlist.Variable.scope &= empty
Variable.multiplicity =
  element UML:Variable.multiplicity {
    attlist.Variable.multiplicity, Multiplicity*
  }
attlist.Variable.multiplicity &= empty
Variable.ordering =
  element UML:Variable.ordering { attlist.Variable.ordering, empty }
attlist.Variable.ordering &= attribute xmi.value { UML.OrderingKind }
UML.VariableFeatures =
  UML.ModelElementFeatures
  | Variable.type
  | Variable.scope
  | Variable.multiplicity
  | Variable.ordering
UML.VariableAtts =
  UML.ModelElementAtts,
  attribute type { xsd:IDREFS }?,
  attribute scope { xsd:IDREFS }?,
  attribute ordering { UML.OrderingKind }?
Variable =
  element UML:Variable { attlist.Variable, UML.VariableFeatures* }
attlist.Variable &= UML.VariableAtts

# ========= UML:ApplyFunctionAction =========

ApplyFunctionAction.function =
  element UML:ApplyFunctionAction.function {
    attlist.ApplyFunctionAction.function, PrimitiveFunction*
  }
attlist.ApplyFunctionAction.function &= empty
UML.ApplyFunctionActionFeatures =
  UML.PrimitiveActionFeatures | ApplyFunctionAction.function
UML.ApplyFunctionActionAtts =
  UML.PrimitiveActionAtts,
  attribute function { xsd:IDREFS }?
ApplyFunctionAction =
  element UML:ApplyFunctionAction {
    attlist.ApplyFunctionAction, UML.ApplyFunctionActionFeatures*
  }
attlist.ApplyFunctionAction &= UML.ApplyFunctionActionAtts

# ========= UML:ArgumentSpecification =========

ArgumentSpecification.type =
  element UML:ArgumentSpecification.type {
    attlist.ArgumentSpecification.type, DataType*
  }
attlist.ArgumentSpecification.type &= empty
ArgumentSpecification.multiplicity =
  element UML:ArgumentSpecification.multiplicity {
    attlist.ArgumentSpecification.multiplicity, Multiplicity*
  }
attlist.ArgumentSpecification.multiplicity &= empty
ArgumentSpecification.ordering =
  element UML:ArgumentSpecification.ordering {
    attlist.ArgumentSpecification.ordering, empty
  }
attlist.ArgumentSpecification.ordering &=
  attribute xmi.value { UML.OrderingKind }
UML.ArgumentSpecificationFeatures =
  UML.ModelElementFeatures
  | ArgumentSpecification.type
  | ArgumentSpecification.multiplicity
  | ArgumentSpecification.ordering
UML.ArgumentSpecificationAtts =
  UML.ModelElementAtts,
  attribute type { xsd:IDREFS }?,
  attribute ordering { UML.OrderingKind }?
ArgumentSpecification =
  element UML:ArgumentSpecification {
    attlist.ArgumentSpecification, UML.ArgumentSpecificationFeatures*
  }
attlist.ArgumentSpecification &= UML.ArgumentSpecificationAtts

# ========= UML:CodeAction =========

CodeAction.language =
  element UML:CodeAction.language {
    attlist.CodeAction.language, (text | XMI.reference)*
  }
attlist.CodeAction.language &= empty
CodeAction.encoding =
  element UML:CodeAction.encoding {
    attlist.CodeAction.encoding, (text | XMI.reference)*
  }
attlist.CodeAction.encoding &= empty
UML.CodeActionFeatures =
  UML.PrimitiveActionFeatures
  | CodeAction.language
  | CodeAction.encoding
UML.CodeActionAtts =
  UML.PrimitiveActionAtts,
  attribute language { text }?,
  attribute encoding { text }?
CodeAction =
  element UML:CodeAction { attlist.CodeAction, UML.CodeActionFeatures* }
attlist.CodeAction &= UML.CodeActionAtts

# ========= UML:LiteralValueAction =========

LiteralValueAction.value =
  element UML:LiteralValueAction.value {
    attlist.LiteralValueAction.value, DataValue*
  }
attlist.LiteralValueAction.value &= empty
UML.LiteralValueActionFeatures =
  UML.PrimitiveActionFeatures | LiteralValueAction.value
UML.LiteralValueActionAtts =
  UML.PrimitiveActionAtts,
  attribute value { xsd:IDREFS }?
LiteralValueAction =
  element UML:LiteralValueAction {
    attlist.LiteralValueAction, UML.LiteralValueActionFeatures*
  }
attlist.LiteralValueAction &= UML.LiteralValueActionAtts

# ========= UML:MarshalAction =========

MarshalAction.marshalType =
  element UML:MarshalAction.marshalType {
    attlist.MarshalAction.marshalType, Class*
  }
attlist.MarshalAction.marshalType &= empty
UML.MarshalActionFeatures =
  UML.PrimitiveActionFeatures | MarshalAction.marshalType
UML.MarshalActionAtts =
  UML.PrimitiveActionAtts,
  attribute marshalType { xsd:IDREFS }?
MarshalAction =
  element UML:MarshalAction {
    attlist.MarshalAction, UML.MarshalActionFeatures*
  }
attlist.MarshalAction &= UML.MarshalActionAtts

# ========= UML:NullAction =========

UML.NullActionFeatures = UML.PrimitiveActionFeatures
UML.NullActionAtts = UML.PrimitiveActionAtts
NullAction =
  element UML:NullAction { attlist.NullAction, UML.NullActionFeatures* }
attlist.NullAction &= UML.NullActionAtts

# ========= UML:PrimitiveFunction =========

PrimitiveFunction.inputSpec =
  element UML:PrimitiveFunction.inputSpec {
    attlist.PrimitiveFunction.inputSpec, ArgumentSpecification*
  }
attlist.PrimitiveFunction.inputSpec &= empty
PrimitiveFunction.outputSpec =
  element UML:PrimitiveFunction.outputSpec {
    attlist.PrimitiveFunction.outputSpec, ArgumentSpecification*
  }
attlist.PrimitiveFunction.outputSpec &= empty
PrimitiveFunction.language =
  element UML:PrimitiveFunction.language {
    attlist.PrimitiveFunction.language, (text | XMI.reference)*
  }
attlist.PrimitiveFunction.language &= empty
PrimitiveFunction.encoding =
  element UML:PrimitiveFunction.encoding {
    attlist.PrimitiveFunction.encoding, (text | XMI.reference)*
  }
attlist.PrimitiveFunction.encoding &= empty
UML.PrimitiveFunctionFeatures =
  UML.ModelElementFeatures
  | PrimitiveFunction.inputSpec
  | PrimitiveFunction.outputSpec
  | PrimitiveFunction.language
  | PrimitiveFunction.encoding
UML.PrimitiveFunctionAtts =
  UML.ModelElementAtts,
  attribute inputSpec { xsd:IDREFS }?,
  attribute outputSpec { xsd:IDREFS }?,
  attribute language { text }?,
  attribute encoding { text }?
PrimitiveFunction =
  element UML:PrimitiveFunction {
    attlist.PrimitiveFunction, UML.PrimitiveFunctionFeatures*
  }
attlist.PrimitiveFunction &= UML.PrimitiveFunctionAtts

# ========= UML:TestIdentityAction =========

UML.TestIdentityActionFeatures = UML.PrimitiveActionFeatures
UML.TestIdentityActionAtts = UML.PrimitiveActionAtts
TestIdentityAction =
  element UML:TestIdentityAction {
    attlist.TestIdentityAction, UML.TestIdentityActionFeatures*
  }
attlist.TestIdentityAction &= UML.TestIdentityActionAtts

# ========= UML:UnmarshalAction =========

UnmarshalAction.unmarshalType =
  element UML:UnmarshalAction.unmarshalType {
    attlist.UnmarshalAction.unmarshalType, Class*
  }
attlist.UnmarshalAction.unmarshalType &= empty
UML.UnmarshalActionFeatures =
  UML.PrimitiveActionFeatures | UnmarshalAction.unmarshalType
UML.UnmarshalActionAtts =
  UML.PrimitiveActionAtts,
  attribute unmarshalType { xsd:IDREFS }?
UnmarshalAction =
  element UML:UnmarshalAction {
    attlist.UnmarshalAction, UML.UnmarshalActionFeatures*
  }
attlist.UnmarshalAction &= UML.UnmarshalActionAtts

# ========= UML:JumpHandler =========

JumpHandler.protectedAction =
  element UML:JumpHandler.protectedAction {
    attlist.JumpHandler.protectedAction, Action*
  }
attlist.JumpHandler.protectedAction &= empty
JumpHandler.jumpType =
  element UML:JumpHandler.jumpType {
    attlist.JumpHandler.jumpType, Classifier*
  }
attlist.JumpHandler.jumpType &= empty
JumpHandler.body =
  element UML:JumpHandler.body {
    attlist.JumpHandler.body, HandlerAction*
  }
attlist.JumpHandler.body &= empty
UML.JumpHandlerFeatures =
  XMI.extension
  | JumpHandler.protectedAction
  | JumpHandler.jumpType
  | JumpHandler.body
UML.JumpHandlerAtts =
  XMI.element.att,
  XMI.link.att,
  attribute protectedAction { xsd:IDREFS }?,
  attribute jumpType { xsd:IDREFS }?,
  attribute body { xsd:IDREFS }?
JumpHandler =
  element UML:JumpHandler {
    attlist.JumpHandler, UML.JumpHandlerFeatures*
  }
attlist.JumpHandler &= UML.JumpHandlerAtts

# ========= UML:HandlerAction =========

HandlerAction.handlerOutput =
  element UML:HandlerAction.handlerOutput {
    attlist.HandlerAction.handlerOutput, OutputPin*
  }
attlist.HandlerAction.handlerOutput &= empty
HandlerAction.body =
  element UML:HandlerAction.body {
    attlist.HandlerAction.body,
    (Action
     | CollectionAction
     | FilterAction
     | IterateAction
     | MapAction
     | ReduceAction
     | ConditionalAction
     | GroupAction
     | LoopAction
     | HandlerAction
     | PrimitiveAction
     | ApplyFunctionAction
     | CodeAction
     | LiteralValueAction
     | MarshalAction
     | NullAction
     | TestIdentityAction
     | UnmarshalAction
     | JumpAction
     | InvocationAction
     | AsynchronousInvocationAction
     | SynchronousInvocationAction
     | ClearAssociationAction
     | LinkAction
     | ReadLinkAction
     | WriteLinkAction
     | CreateLinkAction
     | CreateLinkObjectAction
     | DestroyLinkAction
     | ReadLinkObjectEndAction
     | ReadLinkObjectQualifierAction
     | AttributeAction
     | ClearAttributeAction
     | ReadAttributeAction
     | WriteAttributeAction
     | AddAttributeValueAction
     | RemoveAttributeValueAction
     | CreateObjectAction
     | DestroyObjectAction
     | ReadIsClassifiedObjectAction
     | ReclassifyObjectAction
     | ReadExtentAction
     | ReadSelfAction
     | StartObjectStateMachineAction
     | VariableAction
     | ClearVariableAction
     | ReadVariableAction
     | WriteVariableAction
     | AddVariableValueAction
     | RemoveVariableValueAction
     | ExplicitInvocationActtion
     | CallOperationAction
     | SendSignalAction
     | BroadcastSignalAction
     | CallProcedureAction)*
  }
attlist.HandlerAction.body &= empty
UML.HandlerActionFeatures =
  UML.ActionFeatures | HandlerAction.handlerOutput | HandlerAction.body
UML.HandlerActionAtts =
  UML.ActionAtts,
  attribute handlerOutput { xsd:IDREFS }?
HandlerAction =
  element UML:HandlerAction {
    attlist.HandlerAction, UML.HandlerActionFeatures*
  }
attlist.HandlerAction &= UML.HandlerActionAtts

# ========= UML:JumpAction =========

JumpAction.exception =
  element UML:JumpAction.exception {
    attlist.JumpAction.exception, Exception*
  }
attlist.JumpAction.exception &= empty
UML.JumpActionFeatures =
  UML.PrimitiveActionFeatures | JumpAction.exception
UML.JumpActionAtts =
  UML.PrimitiveActionAtts,
  attribute exception { xsd:IDREFS }?
JumpAction =
  element UML:JumpAction { attlist.JumpAction, UML.JumpActionFeatures* }
attlist.JumpAction &= UML.JumpActionAtts

# ========= UML:InvocationAction =========

UML.InvocationActionFeatures = UML.PrimitiveActionFeatures
UML.InvocationActionAtts = UML.PrimitiveActionAtts
InvocationAction =
  element UML:InvocationAction {
    attlist.InvocationAction, UML.InvocationActionFeatures*
  }
attlist.InvocationAction &= UML.InvocationActionAtts

# ========= UML:AsynchronousInvocationAction =========

AsynchronousInvocationAction.isRepliable =
  element UML:AsynchronousInvocationAction.isRepliable {
    attlist.AsynchronousInvocationAction.isRepliable, empty
  }
attlist.AsynchronousInvocationAction.isRepliable &=
  attribute xmi.value { "true" | "false" }
UML.AsynchronousInvocationActionFeatures =
  UML.InvocationActionFeatures
  | AsynchronousInvocationAction.isRepliable
UML.AsynchronousInvocationActionAtts =
  UML.InvocationActionAtts,
  attribute isRepliable { "true" | "false" }?
AsynchronousInvocationAction =
  element UML:AsynchronousInvocationAction {
    attlist.AsynchronousInvocationAction,
    UML.AsynchronousInvocationActionFeatures*
  }
attlist.AsynchronousInvocationAction &=
  UML.AsynchronousInvocationActionAtts

# ========= UML:ExplicitInvocationActtion =========

UML.ExplicitInvocationActtionFeatures = UML.PrimitiveActionFeatures
UML.ExplicitInvocationActtionAtts = UML.PrimitiveActionAtts
ExplicitInvocationActtion =
  element UML:ExplicitInvocationActtion {
    attlist.ExplicitInvocationActtion,
    UML.ExplicitInvocationActtionFeatures*
  }
attlist.ExplicitInvocationActtion &= UML.ExplicitInvocationActtionAtts

# ========= UML:CallOperationAction =========

CallOperationAction.operation =
  element UML:CallOperationAction.operation {
    attlist.CallOperationAction.operation, Operation*
  }
attlist.CallOperationAction.operation &= empty
CallOperationAction.isAsynchronous =
  element UML:CallOperationAction.isAsynchronous {
    attlist.CallOperationAction.isAsynchronous, empty
  }
attlist.CallOperationAction.isAsynchronous &=
  attribute xmi.value { "true" | "false" }
UML.CallOperationActionFeatures =
  UML.ExplicitInvocationActtionFeatures
  | CallOperationAction.operation
  | CallOperationAction.isAsynchronous
UML.CallOperationActionAtts =
  UML.ExplicitInvocationActtionAtts,
  attribute operation { xsd:IDREFS }?,
  attribute isAsynchronous { "true" | "false" }?
CallOperationAction =
  element UML:CallOperationAction {
    attlist.CallOperationAction, UML.CallOperationActionFeatures*
  }
attlist.CallOperationAction &= UML.CallOperationActionAtts

# ========= UML:SynchronousInvocationAction =========

UML.SynchronousInvocationActionFeatures = UML.InvocationActionFeatures
UML.SynchronousInvocationActionAtts = UML.InvocationActionAtts
SynchronousInvocationAction =
  element UML:SynchronousInvocationAction {
    attlist.SynchronousInvocationAction,
    UML.SynchronousInvocationActionFeatures*
  }
attlist.SynchronousInvocationAction &=
  UML.SynchronousInvocationActionAtts

# ========= UML:ClearAssociationAction =========

ClearAssociationAction.association =
  element UML:ClearAssociationAction.association {
    attlist.ClearAssociationAction.association, Association*
  }
attlist.ClearAssociationAction.association &= empty
UML.ClearAssociationActionFeatures =
  UML.PrimitiveActionFeatures | ClearAssociationAction.association
UML.ClearAssociationActionAtts =
  UML.PrimitiveActionAtts,
  attribute association { xsd:IDREFS }?
ClearAssociationAction =
  element UML:ClearAssociationAction {
    attlist.ClearAssociationAction, UML.ClearAssociationActionFeatures*
  }
attlist.ClearAssociationAction &= UML.ClearAssociationActionAtts

# ========= UML:LinkAction =========

LinkAction.endData =
  element UML:LinkAction.endData {
    attlist.LinkAction.endData, (LinkEndData | LinkEndCreationData)*
  }
attlist.LinkAction.endData &= empty
UML.LinkActionFeatures =
  UML.PrimitiveActionFeatures | LinkAction.endData
UML.LinkActionAtts = UML.PrimitiveActionAtts
LinkAction =
  element UML:LinkAction { attlist.LinkAction, UML.LinkActionFeatures* }
attlist.LinkAction &= UML.LinkActionAtts

# ========= UML:WriteLinkAction =========

UML.WriteLinkActionFeatures = UML.LinkActionFeatures
UML.WriteLinkActionAtts = UML.LinkActionAtts
WriteLinkAction =
  element UML:WriteLinkAction {
    attlist.WriteLinkAction, UML.WriteLinkActionFeatures*
  }
attlist.WriteLinkAction &= UML.WriteLinkActionAtts

# ========= UML:CreateLinkAction =========

UML.CreateLinkActionFeatures = UML.WriteLinkActionFeatures
UML.CreateLinkActionAtts = UML.WriteLinkActionAtts
CreateLinkAction =
  element UML:CreateLinkAction {
    attlist.CreateLinkAction, UML.CreateLinkActionFeatures*
  }
attlist.CreateLinkAction &= UML.CreateLinkActionAtts

# ========= UML:CreateLinkObjectAction =========

UML.CreateLinkObjectActionFeatures = UML.CreateLinkActionFeatures
UML.CreateLinkObjectActionAtts = UML.CreateLinkActionAtts
CreateLinkObjectAction =
  element UML:CreateLinkObjectAction {
    attlist.CreateLinkObjectAction, UML.CreateLinkObjectActionFeatures*
  }
attlist.CreateLinkObjectAction &= UML.CreateLinkObjectActionAtts

# ========= UML:DestroyLinkAction =========

UML.DestroyLinkActionFeatures = UML.WriteLinkActionFeatures
UML.DestroyLinkActionAtts = UML.WriteLinkActionAtts
DestroyLinkAction =
  element UML:DestroyLinkAction {
    attlist.DestroyLinkAction, UML.DestroyLinkActionFeatures*
  }
attlist.DestroyLinkAction &= UML.DestroyLinkActionAtts

# ========= UML:LinkEndData =========

LinkEndData.end =
  element UML:LinkEndData.end {
    attlist.LinkEndData.end, AssociationEnd*
  }
attlist.LinkEndData.end &= empty
LinkEndData.qualifier =
  element UML:LinkEndData.qualifier {
    attlist.LinkEndData.qualifier, QualifierValue*
  }
attlist.LinkEndData.qualifier &= empty
UML.LinkEndDataFeatures =
  XMI.extension | LinkEndData.end | LinkEndData.qualifier
UML.LinkEndDataAtts =
  XMI.element.att,
  XMI.link.att,
  attribute end { xsd:IDREFS }?
LinkEndData =
  element UML:LinkEndData {
    attlist.LinkEndData, UML.LinkEndDataFeatures*
  }
attlist.LinkEndData &= UML.LinkEndDataAtts

# ========= UML:LinkEndCreationData =========

LinkEndCreationData.isReplaceAll =
  element UML:LinkEndCreationData.isReplaceAll {
    attlist.LinkEndCreationData.isReplaceAll, empty
  }
attlist.LinkEndCreationData.isReplaceAll &=
  attribute xmi.value { "true" | "false" }
UML.LinkEndCreationDataFeatures =
  UML.LinkEndDataFeatures | LinkEndCreationData.isReplaceAll
UML.LinkEndCreationDataAtts =
  UML.LinkEndDataAtts,
  attribute isReplaceAll { "true" | "false" }?
LinkEndCreationData =
  element UML:LinkEndCreationData {
    attlist.LinkEndCreationData, UML.LinkEndCreationDataFeatures*
  }
attlist.LinkEndCreationData &= UML.LinkEndCreationDataAtts

# ========= UML:QualifierValue =========

QualifierValue.qualifier =
  element UML:QualifierValue.qualifier {
    attlist.QualifierValue.qualifier, Attribute*
  }
attlist.QualifierValue.qualifier &= empty
UML.QualifierValueFeatures = XMI.extension | QualifierValue.qualifier
UML.QualifierValueAtts =
  XMI.element.att,
  XMI.link.att,
  attribute qualifier { xsd:IDREFS }?
QualifierValue =
  element UML:QualifierValue {
    attlist.QualifierValue, UML.QualifierValueFeatures*
  }
attlist.QualifierValue &= UML.QualifierValueAtts

# ========= UML:ReadLinkAction =========

UML.ReadLinkActionFeatures = UML.LinkActionFeatures
UML.ReadLinkActionAtts = UML.LinkActionAtts
ReadLinkAction =
  element UML:ReadLinkAction {
    attlist.ReadLinkAction, UML.ReadLinkActionFeatures*
  }
attlist.ReadLinkAction &= UML.ReadLinkActionAtts

# ========= UML:ReadLinkObjectEndAction =========

ReadLinkObjectEndAction.end =
  element UML:ReadLinkObjectEndAction.end {
    attlist.ReadLinkObjectEndAction.end, AssociationEnd*
  }
attlist.ReadLinkObjectEndAction.end &= empty
UML.ReadLinkObjectEndActionFeatures =
  UML.PrimitiveActionFeatures | ReadLinkObjectEndAction.end
UML.ReadLinkObjectEndActionAtts =
  UML.PrimitiveActionAtts,
  attribute end { xsd:IDREFS }?
ReadLinkObjectEndAction =
  element UML:ReadLinkObjectEndAction {
    attlist.ReadLinkObjectEndAction,
    UML.ReadLinkObjectEndActionFeatures*
  }
attlist.ReadLinkObjectEndAction &= UML.ReadLinkObjectEndActionAtts

# ========= UML:ReadLinkObjectQualifierAction =========

ReadLinkObjectQualifierAction.qualifier =
  element UML:ReadLinkObjectQualifierAction.qualifier {
    attlist.ReadLinkObjectQualifierAction.qualifier, Attribute*
  }
attlist.ReadLinkObjectQualifierAction.qualifier &= empty
UML.ReadLinkObjectQualifierActionFeatures =
  UML.PrimitiveActionFeatures | ReadLinkObjectQualifierAction.qualifier
UML.ReadLinkObjectQualifierActionAtts =
  UML.PrimitiveActionAtts,
  attribute qualifier { xsd:IDREFS }?
ReadLinkObjectQualifierAction =
  element UML:ReadLinkObjectQualifierAction {
    attlist.ReadLinkObjectQualifierAction,
    UML.ReadLinkObjectQualifierActionFeatures*
  }
attlist.ReadLinkObjectQualifierAction &=
  UML.ReadLinkObjectQualifierActionAtts

# ========= UML:AttributeAction =========

AttributeAction.attribute =
  element UML:AttributeAction.attribute {
    attlist.AttributeAction.attribute, Attribute*
  }
attlist.AttributeAction.attribute &= empty
UML.AttributeActionFeatures =
  UML.PrimitiveActionFeatures | AttributeAction.attribute
UML.AttributeActionAtts =
  UML.PrimitiveActionAtts,
  attribute attribute { xsd:IDREFS }?
AttributeAction =
  element UML:AttributeAction {
    attlist.AttributeAction, UML.AttributeActionFeatures*
  }
attlist.AttributeAction &= UML.AttributeActionAtts

# ========= UML:WriteAttributeAction =========

UML.WriteAttributeActionFeatures = UML.AttributeActionFeatures
UML.WriteAttributeActionAtts = UML.AttributeActionAtts
WriteAttributeAction =
  element UML:WriteAttributeAction {
    attlist.WriteAttributeAction, UML.WriteAttributeActionFeatures*
  }
attlist.WriteAttributeAction &= UML.WriteAttributeActionAtts

# ========= UML:AddAttributeValueAction =========

AddAttributeValueAction.isReplaceAll =
  element UML:AddAttributeValueAction.isReplaceAll {
    attlist.AddAttributeValueAction.isReplaceAll, empty
  }
attlist.AddAttributeValueAction.isReplaceAll &=
  attribute xmi.value { "true" | "false" }
UML.AddAttributeValueActionFeatures =
  UML.WriteAttributeActionFeatures
  | AddAttributeValueAction.isReplaceAll
UML.AddAttributeValueActionAtts =
  UML.WriteAttributeActionAtts,
  attribute isReplaceAll { "true" | "false" }?
AddAttributeValueAction =
  element UML:AddAttributeValueAction {
    attlist.AddAttributeValueAction,
    UML.AddAttributeValueActionFeatures*
  }
attlist.AddAttributeValueAction &= UML.AddAttributeValueActionAtts

# ========= UML:ClearAttributeAction =========

UML.ClearAttributeActionFeatures = UML.AttributeActionFeatures
UML.ClearAttributeActionAtts = UML.AttributeActionAtts
ClearAttributeAction =
  element UML:ClearAttributeAction {
    attlist.ClearAttributeAction, UML.ClearAttributeActionFeatures*
  }
attlist.ClearAttributeAction &= UML.ClearAttributeActionAtts

# ========= UML:ReadAttributeAction =========

UML.ReadAttributeActionFeatures = UML.AttributeActionFeatures
UML.ReadAttributeActionAtts = UML.AttributeActionAtts
ReadAttributeAction =
  element UML:ReadAttributeAction {
    attlist.ReadAttributeAction, UML.ReadAttributeActionFeatures*
  }
attlist.ReadAttributeAction &= UML.ReadAttributeActionAtts

# ========= UML:RemoveAttributeValueAction =========

UML.RemoveAttributeValueActionFeatures =
  UML.WriteAttributeActionFeatures
UML.RemoveAttributeValueActionAtts = UML.WriteAttributeActionAtts
RemoveAttributeValueAction =
  element UML:RemoveAttributeValueAction {
    attlist.RemoveAttributeValueAction,
    UML.RemoveAttributeValueActionFeatures*
  }
attlist.RemoveAttributeValueAction &= UML.RemoveAttributeValueActionAtts

# ========= UML:CreateObjectAction =========

CreateObjectAction.classifier =
  element UML:CreateObjectAction.classifier {
    attlist.CreateObjectAction.classifier, Classifier*
  }
attlist.CreateObjectAction.classifier &= empty
UML.CreateObjectActionFeatures =
  UML.PrimitiveActionFeatures | CreateObjectAction.classifier
UML.CreateObjectActionAtts =
  UML.PrimitiveActionAtts,
  attribute classifier { xsd:IDREFS }?
CreateObjectAction =
  element UML:CreateObjectAction {
    attlist.CreateObjectAction, UML.CreateObjectActionFeatures*
  }
attlist.CreateObjectAction &= UML.CreateObjectActionAtts

# ========= UML:DestroyObjectAction =========

UML.DestroyObjectActionFeatures = UML.PrimitiveActionFeatures
UML.DestroyObjectActionAtts = UML.PrimitiveActionAtts
DestroyObjectAction =
  element UML:DestroyObjectAction {
    attlist.DestroyObjectAction, UML.DestroyObjectActionFeatures*
  }
attlist.DestroyObjectAction &= UML.DestroyObjectActionAtts

# ========= UML:ReadIsClassifiedObjectAction =========

ReadIsClassifiedObjectAction.classifier =
  element UML:ReadIsClassifiedObjectAction.classifier {
    attlist.ReadIsClassifiedObjectAction.classifier, Classifier*
  }
attlist.ReadIsClassifiedObjectAction.classifier &= empty
ReadIsClassifiedObjectAction.isDirect =
  element UML:ReadIsClassifiedObjectAction.isDirect {
    attlist.ReadIsClassifiedObjectAction.isDirect, empty
  }
attlist.ReadIsClassifiedObjectAction.isDirect &=
  attribute xmi.value { "true" | "false" }
UML.ReadIsClassifiedObjectActionFeatures =
  UML.PrimitiveActionFeatures
  | ReadIsClassifiedObjectAction.classifier
  | ReadIsClassifiedObjectAction.isDirect
UML.ReadIsClassifiedObjectActionAtts =
  UML.PrimitiveActionAtts,
  attribute classifier { xsd:IDREFS }?,
  attribute isDirect { "true" | "false" }?
ReadIsClassifiedObjectAction =
  element UML:ReadIsClassifiedObjectAction {
    attlist.ReadIsClassifiedObjectAction,
    UML.ReadIsClassifiedObjectActionFeatures*
  }
attlist.ReadIsClassifiedObjectAction &=
  UML.ReadIsClassifiedObjectActionAtts

# ========= UML:ReclassifyObjectAction =========

ReclassifyObjectAction.oldClassifier =
  element UML:ReclassifyObjectAction.oldClassifier {
    attlist.ReclassifyObjectAction.oldClassifier, Classifier*
  }
attlist.ReclassifyObjectAction.oldClassifier &= empty
ReclassifyObjectAction.newClassifier =
  element UML:ReclassifyObjectAction.newClassifier {
    attlist.ReclassifyObjectAction.newClassifier, Classifier*
  }
attlist.ReclassifyObjectAction.newClassifier &= empty
ReclassifyObjectAction.isReplaceAll =
  element UML:ReclassifyObjectAction.isReplaceAll {
    attlist.ReclassifyObjectAction.isReplaceAll, empty
  }
attlist.ReclassifyObjectAction.isReplaceAll &=
  attribute xmi.value { "true" | "false" }
UML.ReclassifyObjectActionFeatures =
  UML.PrimitiveActionFeatures
  | ReclassifyObjectAction.oldClassifier
  | ReclassifyObjectAction.newClassifier
  | ReclassifyObjectAction.isReplaceAll
UML.ReclassifyObjectActionAtts =
  UML.PrimitiveActionAtts,
  attribute oldClassifier { xsd:IDREFS }?,
  attribute newClassifier { xsd:IDREFS }?,
  attribute isReplaceAll { "true" | "false" }?
ReclassifyObjectAction =
  element UML:ReclassifyObjectAction {
    attlist.ReclassifyObjectAction, UML.ReclassifyObjectActionFeatures*
  }
attlist.ReclassifyObjectAction &= UML.ReclassifyObjectActionAtts

# ========= UML:ReadExtentAction =========

ReadExtentAction.classifier =
  element UML:ReadExtentAction.classifier {
    attlist.ReadExtentAction.classifier, Classifier*
  }
attlist.ReadExtentAction.classifier &= empty
UML.ReadExtentActionFeatures =
  UML.PrimitiveActionFeatures | ReadExtentAction.classifier
UML.ReadExtentActionAtts =
  UML.PrimitiveActionAtts,
  attribute classifier { xsd:IDREFS }?
ReadExtentAction =
  element UML:ReadExtentAction {
    attlist.ReadExtentAction, UML.ReadExtentActionFeatures*
  }
attlist.ReadExtentAction &= UML.ReadExtentActionAtts

# ========= UML:ReadSelfAction =========

UML.ReadSelfActionFeatures = UML.PrimitiveActionFeatures
UML.ReadSelfActionAtts = UML.PrimitiveActionAtts
ReadSelfAction =
  element UML:ReadSelfAction {
    attlist.ReadSelfAction, UML.ReadSelfActionFeatures*
  }
attlist.ReadSelfAction &= UML.ReadSelfActionAtts

# ========= UML:StartObjectStateMachineAction =========

UML.StartObjectStateMachineActionFeatures = UML.PrimitiveActionFeatures
UML.StartObjectStateMachineActionAtts = UML.PrimitiveActionAtts
StartObjectStateMachineAction =
  element UML:StartObjectStateMachineAction {
    attlist.StartObjectStateMachineAction,
    UML.StartObjectStateMachineActionFeatures*
  }
attlist.StartObjectStateMachineAction &=
  UML.StartObjectStateMachineActionAtts

# ========= UML:VariableAction =========

VariableAction.variable =
  element UML:VariableAction.variable {
    attlist.VariableAction.variable, Variable*
  }
attlist.VariableAction.variable &= empty
UML.VariableActionFeatures =
  UML.PrimitiveActionFeatures | VariableAction.variable
UML.VariableActionAtts =
  UML.PrimitiveActionAtts,
  attribute variable { xsd:IDREFS }?
VariableAction =
  element UML:VariableAction {
    attlist.VariableAction, UML.VariableActionFeatures*
  }
attlist.VariableAction &= UML.VariableActionAtts

# ========= UML:WriteVariableAction =========

UML.WriteVariableActionFeatures = UML.VariableActionFeatures
UML.WriteVariableActionAtts = UML.VariableActionAtts
WriteVariableAction =
  element UML:WriteVariableAction {
    attlist.WriteVariableAction, UML.WriteVariableActionFeatures*
  }
attlist.WriteVariableAction &= UML.WriteVariableActionAtts

# ========= UML:AddVariableValueAction =========

AddVariableValueAction.isReplaceAll =
  element UML:AddVariableValueAction.isReplaceAll {
    attlist.AddVariableValueAction.isReplaceAll, empty
  }
attlist.AddVariableValueAction.isReplaceAll &=
  attribute xmi.value { "true" | "false" }
UML.AddVariableValueActionFeatures =
  UML.WriteVariableActionFeatures | AddVariableValueAction.isReplaceAll
UML.AddVariableValueActionAtts =
  UML.WriteVariableActionAtts,
  attribute isReplaceAll { "true" | "false" }?
AddVariableValueAction =
  element UML:AddVariableValueAction {
    attlist.AddVariableValueAction, UML.AddVariableValueActionFeatures*
  }
attlist.AddVariableValueAction &= UML.AddVariableValueActionAtts

# ========= UML:ClearVariableAction =========

UML.ClearVariableActionFeatures = UML.VariableActionFeatures
UML.ClearVariableActionAtts = UML.VariableActionAtts
ClearVariableAction =
  element UML:ClearVariableAction {
    attlist.ClearVariableAction, UML.ClearVariableActionFeatures*
  }
attlist.ClearVariableAction &= UML.ClearVariableActionAtts

# ========= UML:ReadVariableAction =========

UML.ReadVariableActionFeatures = UML.VariableActionFeatures
UML.ReadVariableActionAtts = UML.VariableActionAtts
ReadVariableAction =
  element UML:ReadVariableAction {
    attlist.ReadVariableAction, UML.ReadVariableActionFeatures*
  }
attlist.ReadVariableAction &= UML.ReadVariableActionAtts

# ========= UML:RemoveVariableValueAction =========

UML.RemoveVariableValueActionFeatures = UML.WriteVariableActionFeatures
UML.RemoveVariableValueActionAtts = UML.WriteVariableActionAtts
RemoveVariableValueAction =
  element UML:RemoveVariableValueAction {
    attlist.RemoveVariableValueAction,
    UML.RemoveVariableValueActionFeatures*
  }
attlist.RemoveVariableValueAction &= UML.RemoveVariableValueActionAtts

# ========= UML:SendSignalAction =========

SendSignalAction.signal =
  element UML:SendSignalAction.signal {
    attlist.SendSignalAction.signal, Signal*
  }
attlist.SendSignalAction.signal &= empty
UML.SendSignalActionFeatures =
  UML.ExplicitInvocationActtionFeatures | SendSignalAction.signal
UML.SendSignalActionAtts =
  UML.ExplicitInvocationActtionAtts,
  attribute signal { xsd:IDREFS }?
SendSignalAction =
  element UML:SendSignalAction {
    attlist.SendSignalAction, UML.SendSignalActionFeatures*
  }
attlist.SendSignalAction &= UML.SendSignalActionAtts

# ========= UML:BroadcastSignalAction =========

BroadcastSignalAction.signal =
  element UML:BroadcastSignalAction.signal {
    attlist.BroadcastSignalAction.signal, Signal*
  }
attlist.BroadcastSignalAction.signal &= empty
UML.BroadcastSignalActionFeatures =
  UML.ExplicitInvocationActtionFeatures | BroadcastSignalAction.signal
UML.BroadcastSignalActionAtts =
  UML.ExplicitInvocationActtionAtts,
  attribute signal { xsd:IDREFS }?
BroadcastSignalAction =
  element UML:BroadcastSignalAction {
    attlist.BroadcastSignalAction, UML.BroadcastSignalActionFeatures*
  }
attlist.BroadcastSignalAction &= UML.BroadcastSignalActionAtts

# ========= UML:CallProcedureAction =========

CallProcedureAction.calledProcedure =
  element UML:CallProcedureAction.calledProcedure {
    attlist.CallProcedureAction.calledProcedure, Procedure*
  }
attlist.CallProcedureAction.calledProcedure &= empty
CallProcedureAction.isSynchronous =
  element UML:CallProcedureAction.isSynchronous {
    attlist.CallProcedureAction.isSynchronous, empty
  }
attlist.CallProcedureAction.isSynchronous &=
  attribute xmi.value { "true" | "false" }
UML.CallProcedureActionFeatures =
  UML.PrimitiveActionFeatures
  | CallProcedureAction.calledProcedure
  | CallProcedureAction.isSynchronous
UML.CallProcedureActionAtts =
  UML.PrimitiveActionAtts,
  attribute calledProcedure { xsd:IDREFS }?,
  attribute isSynchronous { "true" | "false" }?
CallProcedureAction =
  element UML:CallProcedureAction {
    attlist.CallProcedureAction, UML.CallProcedureActionFeatures*
  }
attlist.CallProcedureAction &= UML.CallProcedureActionAtts


# ========= UML:State_Machines =========

# ========= UML:StateMachine =========

StateMachine.context =
  element UML:StateMachine.context {
    attlist.StateMachine.context, ModelElement*
  }
attlist.StateMachine.context &= empty
StateMachine.top =
  element UML:StateMachine.top {
    attlist.StateMachine.top,
    (State
     | CompositeState
     | SubmachineState
     | SubactivityState
     | SimpleState
     | ActionState
     | CallState
     | ObjectFlowState
     | FinalState)*
  }
attlist.StateMachine.top &= empty
StateMachine.transitions =
  element UML:StateMachine.transitions {
    attlist.StateMachine.transitions, Transition*
  }
attlist.StateMachine.transitions &= empty
StateMachine.submachineState =
  element UML:StateMachine.submachineState {
    attlist.StateMachine.submachineState, SubmachineState*
  }
attlist.StateMachine.submachineState &= empty
UML.StateMachineFeatures =
  UML.ModelElementFeatures
  | StateMachine.context
  | StateMachine.top
  | StateMachine.transitions
  | StateMachine.submachineState
UML.StateMachineAtts =
  UML.ModelElementAtts,
  attribute context { xsd:IDREFS }?,
  attribute submachineState { xsd:IDREFS }?
StateMachine =
  element UML:StateMachine {
    attlist.StateMachine, UML.StateMachineFeatures*
  }
attlist.StateMachine &= UML.StateMachineAtts

# ========= UML:Event =========

Event.parameter =
  element UML:Event.parameter { attlist.Event.parameter, Parameter* }
attlist.Event.parameter &= empty
UML.EventFeatures = UML.ModelElementFeatures | Event.parameter
UML.EventAtts = UML.ModelElementAtts
Event = element UML:Event { attlist.Event, UML.EventFeatures* }
attlist.Event &= UML.EventAtts

# ========= UML:StateVertex =========

StateVertex.container =
  element UML:StateVertex.container {
    attlist.StateVertex.container, CompositeState*
  }
attlist.StateVertex.container &= empty
StateVertex.outgoing =
  element UML:StateVertex.outgoing {
    attlist.StateVertex.outgoing, Transition*
  }
attlist.StateVertex.outgoing &= empty
StateVertex.incoming =
  element UML:StateVertex.incoming {
    attlist.StateVertex.incoming, Transition*
  }
attlist.StateVertex.incoming &= empty
UML.StateVertexFeatures =
  UML.ModelElementFeatures
  | StateVertex.container
  | StateVertex.outgoing
  | StateVertex.incoming
UML.StateVertexAtts =
  UML.ModelElementAtts,
  attribute container { xsd:IDREFS }?,
  attribute outgoing { xsd:IDREFS }?,
  attribute incoming { xsd:IDREFS }?
StateVertex =
  element UML:StateVertex {
    attlist.StateVertex, UML.StateVertexFeatures*
  }
attlist.StateVertex &= UML.StateVertexAtts

# ========= UML:State =========

State.entry =
  element UML:State.entry { attlist.State.entry, Procedure* }
attlist.State.entry &= empty
State.exit = element UML:State.exit { attlist.State.exit, Procedure* }
attlist.State.exit &= empty
State.deferrableEvent =
  element UML:State.deferrableEvent {
    attlist.State.deferrableEvent, Event*
  }
attlist.State.deferrableEvent &= empty
State.internalTransition =
  element UML:State.internalTransition {
    attlist.State.internalTransition, Transition*
  }
attlist.State.internalTransition &= empty
State.doActivity =
  element UML:State.doActivity { attlist.State.doActivity, Procedure* }
attlist.State.doActivity &= empty
State.stateMachine =
  element UML:State.stateMachine {
    attlist.State.stateMachine, StateMachine*
  }
attlist.State.stateMachine &= empty
UML.StateFeatures =
  UML.StateVertexFeatures
  | State.entry
  | State.exit
  | State.deferrableEvent
  | State.internalTransition
  | State.doActivity
  | State.stateMachine
UML.StateAtts =
  UML.StateVertexAtts,
  attribute deferrableEvent { xsd:IDREFS }?,
  attribute stateMachine { xsd:IDREFS }?
State = element UML:State { attlist.State, UML.StateFeatures* }
attlist.State &= UML.StateAtts

# ========= UML:TimeEvent =========

TimeEvent.when =
  element UML:TimeEvent.when { attlist.TimeEvent.when, TimeExpression* }
attlist.TimeEvent.when &= empty
UML.TimeEventFeatures = UML.EventFeatures | TimeEvent.when
UML.TimeEventAtts = UML.EventAtts
TimeEvent =
  element UML:TimeEvent { attlist.TimeEvent, UML.TimeEventFeatures* }
attlist.TimeEvent &= UML.TimeEventAtts

# ========= UML:CallEvent =========

CallEvent.operation =
  element UML:CallEvent.operation {
    attlist.CallEvent.operation, Operation*
  }
attlist.CallEvent.operation &= empty
UML.CallEventFeatures = UML.EventFeatures | CallEvent.operation
UML.CallEventAtts =
  UML.EventAtts,
  attribute operation { xsd:IDREFS }?
CallEvent =
  element UML:CallEvent { attlist.CallEvent, UML.CallEventFeatures* }
attlist.CallEvent &= UML.CallEventAtts

# ========= UML:SignalEvent =========

SignalEvent.signal =
  element UML:SignalEvent.signal { attlist.SignalEvent.signal, Signal* }
attlist.SignalEvent.signal &= empty
UML.SignalEventFeatures = UML.EventFeatures | SignalEvent.signal
UML.SignalEventAtts =
  UML.EventAtts,
  attribute signal { xsd:IDREFS }?
SignalEvent =
  element UML:SignalEvent {
    attlist.SignalEvent, UML.SignalEventFeatures*
  }
attlist.SignalEvent &= UML.SignalEventAtts

# ========= UML:Transition =========

Transition.guard =
  element UML:Transition.guard { attlist.Transition.guard, Guard* }
attlist.Transition.guard &= empty
Transition.effect =
  element UML:Transition.effect {
    attlist.Transition.effect, Procedure*
  }
attlist.Transition.effect &= empty
Transition.trigger =
  element UML:Transition.trigger { attlist.Transition.trigger, Event* }
attlist.Transition.trigger &= empty
Transition.source =
  element UML:Transition.source {
    attlist.Transition.source, StateVertex*
  }
attlist.Transition.source &= empty
Transition.target =
  element UML:Transition.target {
    attlist.Transition.target, StateVertex*
  }
attlist.Transition.target &= empty
Transition.stateMachine =
  element UML:Transition.stateMachine {
    attlist.Transition.stateMachine, StateMachine*
  }
attlist.Transition.stateMachine &= empty
UML.TransitionFeatures =
  UML.ModelElementFeatures
  | Transition.guard
  | Transition.effect
  | Transition.trigger
  | Transition.source
  | Transition.target
  | Transition.stateMachine
UML.TransitionAtts =
  UML.ModelElementAtts,
  attribute trigger { xsd:IDREFS }?,
  attribute source { xsd:IDREFS }?,
  attribute target { xsd:IDREFS }?,
  attribute stateMachine { xsd:IDREFS }?
Transition =
  element UML:Transition { attlist.Transition, UML.TransitionFeatures* }
attlist.Transition &= UML.TransitionAtts

# ========= UML:CompositeState =========

CompositeState.isConcurrent =
  element UML:CompositeState.isConcurrent {
    attlist.CompositeState.isConcurrent, empty
  }
attlist.CompositeState.isConcurrent &=
  attribute xmi.value { "true" | "false" }
CompositeState.subvertex =
  element UML:CompositeState.subvertex {
    attlist.CompositeState.subvertex,
    (StateVertex
     | State
     | CompositeState
     | SubmachineState
     | SubactivityState
     | SimpleState
     | ActionState
     | CallState
     | ObjectFlowState
     | FinalState
     | Pseudostate
     | SynchState
     | StubState)*
  }
attlist.CompositeState.subvertex &= empty
UML.CompositeStateFeatures =
  UML.StateFeatures
  | CompositeState.isConcurrent
  | CompositeState.subvertex
UML.CompositeStateAtts =
  UML.StateAtts,
  attribute isConcurrent { "true" | "false" }?
CompositeState =
  element UML:CompositeState {
    attlist.CompositeState, UML.CompositeStateFeatures*
  }
attlist.CompositeState &= UML.CompositeStateAtts

# ========= UML:ChangeEvent =========

ChangeEvent.changeExpression =
  element UML:ChangeEvent.changeExpression {
    attlist.ChangeEvent.changeExpression, BooleanExpression*
  }
attlist.ChangeEvent.changeExpression &= empty
UML.ChangeEventFeatures =
  UML.EventFeatures | ChangeEvent.changeExpression
UML.ChangeEventAtts = UML.EventAtts
ChangeEvent =
  element UML:ChangeEvent {
    attlist.ChangeEvent, UML.ChangeEventFeatures*
  }
attlist.ChangeEvent &= UML.ChangeEventAtts

# ========= UML:Guard =========

Guard.expression =
  element UML:Guard.expression {
    attlist.Guard.expression, BooleanExpression*
  }
attlist.Guard.expression &= empty
Guard.transition =
  element UML:Guard.transition { attlist.Guard.transition, Transition* }
attlist.Guard.transition &= empty
UML.GuardFeatures =
  UML.ModelElementFeatures | Guard.expression | Guard.transition
UML.GuardAtts =
  UML.ModelElementAtts,
  attribute transition { xsd:IDREFS }?
Guard = element UML:Guard { attlist.Guard, UML.GuardFeatures* }
attlist.Guard &= UML.GuardAtts

# ========= UML:Pseudostate =========

Pseudostate.kind =
  element UML:Pseudostate.kind { attlist.Pseudostate.kind, empty }
attlist.Pseudostate.kind &= attribute xmi.value { UML.PseudostateKind }
UML.PseudostateFeatures = UML.StateVertexFeatures | Pseudostate.kind
UML.PseudostateAtts =
  UML.StateVertexAtts,
  attribute kind { UML.PseudostateKind }?
Pseudostate =
  element UML:Pseudostate {
    attlist.Pseudostate, UML.PseudostateFeatures*
  }
attlist.Pseudostate &= UML.PseudostateAtts

# ========= UML:SimpleState =========

UML.SimpleStateFeatures = UML.StateFeatures
UML.SimpleStateAtts = UML.StateAtts
SimpleState =
  element UML:SimpleState {
    attlist.SimpleState, UML.SimpleStateFeatures*
  }
attlist.SimpleState &= UML.SimpleStateAtts

# ========= UML:SubmachineState =========

SubmachineState.submachine =
  element UML:SubmachineState.submachine {
    attlist.SubmachineState.submachine, StateMachine*
  }
attlist.SubmachineState.submachine &= empty
UML.SubmachineStateFeatures =
  UML.CompositeStateFeatures | SubmachineState.submachine
UML.SubmachineStateAtts =
  UML.CompositeStateAtts,
  attribute submachine { xsd:IDREFS }?
SubmachineState =
  element UML:SubmachineState {
    attlist.SubmachineState, UML.SubmachineStateFeatures*
  }
attlist.SubmachineState &= UML.SubmachineStateAtts

# ========= UML:SynchState =========

SynchState.bound =
  element UML:SynchState.bound {
    attlist.SynchState.bound, (text | XMI.reference)*
  }
attlist.SynchState.bound &= empty
UML.SynchStateFeatures = UML.StateVertexFeatures | SynchState.bound
UML.SynchStateAtts =
  UML.StateVertexAtts,
  attribute bound { text }?
SynchState =
  element UML:SynchState { attlist.SynchState, UML.SynchStateFeatures* }
attlist.SynchState &= UML.SynchStateAtts

# ========= UML:StubState =========

StubState.referenceState =
  element UML:StubState.referenceState {
    attlist.StubState.referenceState, (text | XMI.reference)*
  }
attlist.StubState.referenceState &= empty
UML.StubStateFeatures =
  UML.StateVertexFeatures | StubState.referenceState
UML.StubStateAtts =
  UML.StateVertexAtts,
  attribute referenceState { text }?
StubState =
  element UML:StubState { attlist.StubState, UML.StubStateFeatures* }
attlist.StubState &= UML.StubStateAtts

# ========= UML:FinalState =========

UML.FinalStateFeatures = UML.StateFeatures
UML.FinalStateAtts = UML.StateAtts
FinalState =
  element UML:FinalState { attlist.FinalState, UML.FinalStateFeatures* }
attlist.FinalState &= UML.FinalStateAtts


# ========= UML:Activity_Graphs =========

# ========= UML:ActivityGraph =========

ActivityGraph.partition =
  element UML:ActivityGraph.partition {
    attlist.ActivityGraph.partition, Partition*
  }
attlist.ActivityGraph.partition &= empty
UML.ActivityGraphFeatures =
  UML.StateMachineFeatures | ActivityGraph.partition
UML.ActivityGraphAtts = UML.StateMachineAtts
ActivityGraph =
  element UML:ActivityGraph {
    attlist.ActivityGraph, UML.ActivityGraphFeatures*
  }
attlist.ActivityGraph &= UML.ActivityGraphAtts

# ========= UML:Partition =========

Partition.contents =
  element UML:Partition.contents {
    attlist.Partition.contents, ModelElement*
  }
attlist.Partition.contents &= empty
Partition.activityGraph =
  element UML:Partition.activityGraph {
    attlist.Partition.activityGraph, ActivityGraph*
  }
attlist.Partition.activityGraph &= empty
UML.PartitionFeatures =
  UML.ModelElementFeatures
  | Partition.contents
  | Partition.activityGraph
UML.PartitionAtts =
  UML.ModelElementAtts,
  attribute contents { xsd:IDREFS }?,
  attribute activityGraph { xsd:IDREFS }?
Partition =
  element UML:Partition { attlist.Partition, UML.PartitionFeatures* }
attlist.Partition &= UML.PartitionAtts

# ========= UML:SubactivityState =========

SubactivityState.isDynamic =
  element UML:SubactivityState.isDynamic {
    attlist.SubactivityState.isDynamic, empty
  }
attlist.SubactivityState.isDynamic &=
  attribute xmi.value { "true" | "false" }
SubactivityState.dynamicArguments =
  element UML:SubactivityState.dynamicArguments {
    attlist.SubactivityState.dynamicArguments, ArgListsExpression*
  }
attlist.SubactivityState.dynamicArguments &= empty
SubactivityState.dynamicMultiplicity =
  element UML:SubactivityState.dynamicMultiplicity {
    attlist.SubactivityState.dynamicMultiplicity, Multiplicity*
  }
attlist.SubactivityState.dynamicMultiplicity &= empty
UML.SubactivityStateFeatures =
  UML.SubmachineStateFeatures
  | SubactivityState.isDynamic
  | SubactivityState.dynamicArguments
  | SubactivityState.dynamicMultiplicity
UML.SubactivityStateAtts =
  UML.SubmachineStateAtts,
  attribute isDynamic { "true" | "false" }?
SubactivityState =
  element UML:SubactivityState {
    attlist.SubactivityState, UML.SubactivityStateFeatures*
  }
attlist.SubactivityState &= UML.SubactivityStateAtts

# ========= UML:ActionState =========

ActionState.isDynamic =
  element UML:ActionState.isDynamic {
    attlist.ActionState.isDynamic, empty
  }
attlist.ActionState.isDynamic &=
  attribute xmi.value { "true" | "false" }
ActionState.dynamicArguments =
  element UML:ActionState.dynamicArguments {
    attlist.ActionState.dynamicArguments, ArgListsExpression*
  }
attlist.ActionState.dynamicArguments &= empty
ActionState.dynamicMultiplicity =
  element UML:ActionState.dynamicMultiplicity {
    attlist.ActionState.dynamicMultiplicity, Multiplicity*
  }
attlist.ActionState.dynamicMultiplicity &= empty
UML.ActionStateFeatures =
  UML.SimpleStateFeatures
  | ActionState.isDynamic
  | ActionState.dynamicArguments
  | ActionState.dynamicMultiplicity
UML.ActionStateAtts =
  UML.SimpleStateAtts,
  attribute isDynamic { "true" | "false" }?
ActionState =
  element UML:ActionState {
    attlist.ActionState, UML.ActionStateFeatures*
  }
attlist.ActionState &= UML.ActionStateAtts

# ========= UML:CallState =========

UML.CallStateFeatures = UML.ActionStateFeatures
UML.CallStateAtts = UML.ActionStateAtts
CallState =
  element UML:CallState { attlist.CallState, UML.CallStateFeatures* }
attlist.CallState &= UML.CallStateAtts

# ========= UML:ObjectFlowState =========

ObjectFlowState.isSynch =
  element UML:ObjectFlowState.isSynch {
    attlist.ObjectFlowState.isSynch, empty
  }
attlist.ObjectFlowState.isSynch &=
  attribute xmi.value { "true" | "false" }
ObjectFlowState.parameter =
  element UML:ObjectFlowState.parameter {
    attlist.ObjectFlowState.parameter, Parameter*
  }
attlist.ObjectFlowState.parameter &= empty
ObjectFlowState.type =
  element UML:ObjectFlowState.type {
    attlist.ObjectFlowState.type, Classifier*
  }
attlist.ObjectFlowState.type &= empty
UML.ObjectFlowStateFeatures =
  UML.SimpleStateFeatures
  | ObjectFlowState.isSynch
  | ObjectFlowState.parameter
  | ObjectFlowState.type
UML.ObjectFlowStateAtts =
  UML.SimpleStateAtts,
  attribute isSynch { "true" | "false" }?,
  attribute parameter { xsd:IDREFS }?,
  attribute type { xsd:IDREFS }?
ObjectFlowState =
  element UML:ObjectFlowState {
    attlist.ObjectFlowState, UML.ObjectFlowStateFeatures*
  }
attlist.ObjectFlowState &= UML.ObjectFlowStateAtts

# ========= UML:ClassifierInState =========

ClassifierInState.type =
  element UML:ClassifierInState.type {
    attlist.ClassifierInState.type, Classifier*
  }
attlist.ClassifierInState.type &= empty
ClassifierInState.inState =
  element UML:ClassifierInState.inState {
    attlist.ClassifierInState.inState, State*
  }
attlist.ClassifierInState.inState &= empty
UML.ClassifierInStateFeatures =
  UML.ClassifierFeatures
  | ClassifierInState.type
  | ClassifierInState.inState
UML.ClassifierInStateAtts =
  UML.ClassifierAtts,
  attribute type { xsd:IDREFS }?,
  attribute inState { xsd:IDREFS }?
ClassifierInState =
  element UML:ClassifierInState {
    attlist.ClassifierInState, UML.ClassifierInStateFeatures*
  }
attlist.ClassifierInState &= UML.ClassifierInStateAtts


# ========= UML:Collaborations =========

# ========= UML:Collaboration =========

Collaboration.interaction =
  element UML:Collaboration.interaction {
    attlist.Collaboration.interaction, Interaction*
  }
attlist.Collaboration.interaction &= empty
Collaboration.representedClassifier =
  element UML:Collaboration.representedClassifier {
    attlist.Collaboration.representedClassifier, Classifier*
  }
attlist.Collaboration.representedClassifier &= empty
Collaboration.representedOperation =
  element UML:Collaboration.representedOperation {
    attlist.Collaboration.representedOperation, Operation*
  }
attlist.Collaboration.representedOperation &= empty
Collaboration.constrainingElement =
  element UML:Collaboration.constrainingElement {
    attlist.Collaboration.constrainingElement, ModelElement*
  }
attlist.Collaboration.constrainingElement &= empty
Collaboration.usedCollaboration =
  element UML:Collaboration.usedCollaboration {
    attlist.Collaboration.usedCollaboration, Collaboration*
  }
attlist.Collaboration.usedCollaboration &= empty
UML.CollaborationFeatures =
  UML.GeneralizableElementFeatures
  | Namespace.ownedElement
  | Collaboration.interaction
  | Collaboration.representedClassifier
  | Collaboration.representedOperation
  | Collaboration.constrainingElement
  | Collaboration.usedCollaboration
UML.CollaborationAtts =
  UML.GeneralizableElementAtts,
  attribute representedClassifier { xsd:IDREFS }?,
  attribute representedOperation { xsd:IDREFS }?,
  attribute constrainingElement { xsd:IDREFS }?,
  attribute usedCollaboration { xsd:IDREFS }?
Collaboration =
  element UML:Collaboration {
    attlist.Collaboration, UML.CollaborationFeatures*
  }
attlist.Collaboration &= UML.CollaborationAtts

# ========= UML:ClassifierRole =========

ClassifierRole.multiplicity =
  element UML:ClassifierRole.multiplicity {
    attlist.ClassifierRole.multiplicity, Multiplicity*
  }
attlist.ClassifierRole.multiplicity &= empty
ClassifierRole.base =
  element UML:ClassifierRole.base {
    attlist.ClassifierRole.base, Classifier*
  }
attlist.ClassifierRole.base &= empty
ClassifierRole.availableFeature =
  element UML:ClassifierRole.availableFeature {
    attlist.ClassifierRole.availableFeature, Feature*
  }
attlist.ClassifierRole.availableFeature &= empty
ClassifierRole.availableContents =
  element UML:ClassifierRole.availableContents {
    attlist.ClassifierRole.availableContents, ModelElement*
  }
attlist.ClassifierRole.availableContents &= empty
ClassifierRole.conformingInstance =
  element UML:ClassifierRole.conformingInstance {
    attlist.ClassifierRole.conformingInstance, Instance*
  }
attlist.ClassifierRole.conformingInstance &= empty
UML.ClassifierRoleFeatures =
  UML.ClassifierFeatures
  | ClassifierRole.multiplicity
  | ClassifierRole.base
  | ClassifierRole.availableFeature
  | ClassifierRole.availableContents
  | ClassifierRole.conformingInstance
UML.ClassifierRoleAtts =
  UML.ClassifierAtts,
  attribute base { xsd:IDREFS }?,
  attribute availableFeature { xsd:IDREFS }?,
  attribute availableContents { xsd:IDREFS }?,
  attribute conformingInstance { xsd:IDREFS }?
ClassifierRole =
  element UML:ClassifierRole {
    attlist.ClassifierRole, UML.ClassifierRoleFeatures*
  }
attlist.ClassifierRole &= UML.ClassifierRoleAtts

# ========= UML:AssociationRole =========

AssociationRole.multiplicity =
  element UML:AssociationRole.multiplicity {
    attlist.AssociationRole.multiplicity, Multiplicity*
  }
attlist.AssociationRole.multiplicity &= empty
AssociationRole.base =
  element UML:AssociationRole.base {
    attlist.AssociationRole.base, Association*
  }
attlist.AssociationRole.base &= empty
AssociationRole.message =
  element UML:AssociationRole.message {
    attlist.AssociationRole.message, Message*
  }
attlist.AssociationRole.message &= empty
AssociationRole.conformingLink =
  element UML:AssociationRole.conformingLink {
    attlist.AssociationRole.conformingLink, Link*
  }
attlist.AssociationRole.conformingLink &= empty
UML.AssociationRoleFeatures =
  UML.AssociationFeatures
  | AssociationRole.multiplicity
  | AssociationRole.base
  | AssociationRole.message
  | AssociationRole.conformingLink
UML.AssociationRoleAtts =
  UML.AssociationAtts,
  attribute base { xsd:IDREFS }?,
  attribute message { xsd:IDREFS }?,
  attribute conformingLink { xsd:IDREFS }?
AssociationRole =
  element UML:AssociationRole {
    attlist.AssociationRole, UML.AssociationRoleFeatures*
  }
attlist.AssociationRole &= UML.AssociationRoleAtts

# ========= UML:AssociationEndRole =========

AssociationEndRole.collaborationMultiplicity =
  element UML:AssociationEndRole.collaborationMultiplicity {
    attlist.AssociationEndRole.collaborationMultiplicity, Multiplicity*
  }
attlist.AssociationEndRole.collaborationMultiplicity &= empty
AssociationEndRole.base =
  element UML:AssociationEndRole.base {
    attlist.AssociationEndRole.base, AssociationEnd*
  }
attlist.AssociationEndRole.base &= empty
AssociationEndRole.availableQualifier =
  element UML:AssociationEndRole.availableQualifier {
    attlist.AssociationEndRole.availableQualifier, Attribute*
  }
attlist.AssociationEndRole.availableQualifier &= empty
UML.AssociationEndRoleFeatures =
  UML.AssociationEndFeatures
  | AssociationEndRole.collaborationMultiplicity
  | AssociationEndRole.base
  | AssociationEndRole.availableQualifier
UML.AssociationEndRoleAtts =
  UML.AssociationEndAtts,
  attribute base { xsd:IDREFS }?,
  attribute availableQualifier { xsd:IDREFS }?
AssociationEndRole =
  element UML:AssociationEndRole {
    attlist.AssociationEndRole, UML.AssociationEndRoleFeatures*
  }
attlist.AssociationEndRole &= UML.AssociationEndRoleAtts

# ========= UML:Message =========

Message.interaction =
  element UML:Message.interaction {
    attlist.Message.interaction, Interaction*
  }
attlist.Message.interaction &= empty
Message.activator =
  element UML:Message.activator { attlist.Message.activator, Message* }
attlist.Message.activator &= empty
Message.sender =
  element UML:Message.sender { attlist.Message.sender, ClassifierRole* }
attlist.Message.sender &= empty
Message.receiver =
  element UML:Message.receiver {
    attlist.Message.receiver, ClassifierRole*
  }
attlist.Message.receiver &= empty
Message.predecessor =
  element UML:Message.predecessor {
    attlist.Message.predecessor, Message*
  }
attlist.Message.predecessor &= empty
Message.communicationConnection =
  element UML:Message.communicationConnection {
    attlist.Message.communicationConnection, AssociationRole*
  }
attlist.Message.communicationConnection &= empty
Message.procedure =
  element UML:Message.procedure {
    attlist.Message.procedure, Procedure*
  }
attlist.Message.procedure &= empty
Message.conformingStimulus =
  element UML:Message.conformingStimulus {
    attlist.Message.conformingStimulus, Stimulus*
  }
attlist.Message.conformingStimulus &= empty
UML.MessageFeatures =
  UML.ModelElementFeatures
  | Message.interaction
  | Message.activator
  | Message.sender
  | Message.receiver
  | Message.predecessor
  | Message.communicationConnection
  | Message.procedure
  | Message.conformingStimulus
UML.MessageAtts =
  UML.ModelElementAtts,
  attribute interaction { xsd:IDREFS }?,
  attribute activator { xsd:IDREFS }?,
  attribute sender { xsd:IDREFS }?,
  attribute receiver { xsd:IDREFS }?,
  attribute predecessor { xsd:IDREFS }?,
  attribute communicationConnection { xsd:IDREFS }?,
  attribute procedure { xsd:IDREFS }?,
  attribute conformingStimulus { xsd:IDREFS }?
Message = element UML:Message { attlist.Message, UML.MessageFeatures* }
attlist.Message &= UML.MessageAtts

# ========= UML:Interaction =========

Interaction.message =
  element UML:Interaction.message {
    attlist.Interaction.message, Message*
  }
attlist.Interaction.message &= empty
Interaction.context =
  element UML:Interaction.context {
    attlist.Interaction.context, Collaboration*
  }
attlist.Interaction.context &= empty
UML.InteractionFeatures =
  UML.ModelElementFeatures | Interaction.message | Interaction.context
UML.InteractionAtts =
  UML.ModelElementAtts,
  attribute context { xsd:IDREFS }?
Interaction =
  element UML:Interaction {
    attlist.Interaction, UML.InteractionFeatures*
  }
attlist.Interaction &= UML.InteractionAtts

# ========= UML:InteractionInstanceSet =========

InteractionInstanceSet.context =
  element UML:InteractionInstanceSet.context {
    attlist.InteractionInstanceSet.context, CollaborationInstanceSet*
  }
attlist.InteractionInstanceSet.context &= empty
InteractionInstanceSet.interaction =
  element UML:InteractionInstanceSet.interaction {
    attlist.InteractionInstanceSet.interaction, Interaction*
  }
attlist.InteractionInstanceSet.interaction &= empty
InteractionInstanceSet.participatingStimulus =
  element UML:InteractionInstanceSet.participatingStimulus {
    attlist.InteractionInstanceSet.participatingStimulus, Stimulus*
  }
attlist.InteractionInstanceSet.participatingStimulus &= empty
UML.InteractionInstanceSetFeatures =
  UML.ModelElementFeatures
  | InteractionInstanceSet.context
  | InteractionInstanceSet.interaction
  | InteractionInstanceSet.participatingStimulus
UML.InteractionInstanceSetAtts =
  UML.ModelElementAtts,
  attribute context { xsd:IDREFS }?,
  attribute interaction { xsd:IDREFS }?,
  attribute participatingStimulus { xsd:IDREFS }?
InteractionInstanceSet =
  element UML:InteractionInstanceSet {
    attlist.InteractionInstanceSet, UML.InteractionInstanceSetFeatures*
  }
attlist.InteractionInstanceSet &= UML.InteractionInstanceSetAtts

# ========= UML:CollaborationInstanceSet =========

CollaborationInstanceSet.interactionInstanceSet =
  element UML:CollaborationInstanceSet.interactionInstanceSet {
    attlist.CollaborationInstanceSet.interactionInstanceSet,
    InteractionInstanceSet*
  }
attlist.CollaborationInstanceSet.interactionInstanceSet &= empty
CollaborationInstanceSet.collaboration =
  element UML:CollaborationInstanceSet.collaboration {
    attlist.CollaborationInstanceSet.collaboration, Collaboration*
  }
attlist.CollaborationInstanceSet.collaboration &= empty
CollaborationInstanceSet.participatingInstance =
  element UML:CollaborationInstanceSet.participatingInstance {
    attlist.CollaborationInstanceSet.participatingInstance, Instance*
  }
attlist.CollaborationInstanceSet.participatingInstance &= empty
CollaborationInstanceSet.participatingLink =
  element UML:CollaborationInstanceSet.participatingLink {
    attlist.CollaborationInstanceSet.participatingLink, Link*
  }
attlist.CollaborationInstanceSet.participatingLink &= empty
CollaborationInstanceSet.constrainingElement =
  element UML:CollaborationInstanceSet.constrainingElement {
    attlist.CollaborationInstanceSet.constrainingElement, ModelElement*
  }
attlist.CollaborationInstanceSet.constrainingElement &= empty
UML.CollaborationInstanceSetFeatures =
  UML.ModelElementFeatures
  | CollaborationInstanceSet.interactionInstanceSet
  | CollaborationInstanceSet.collaboration
  | CollaborationInstanceSet.participatingInstance
  | CollaborationInstanceSet.participatingLink
  | CollaborationInstanceSet.constrainingElement
UML.CollaborationInstanceSetAtts =
  UML.ModelElementAtts,
  attribute collaboration { xsd:IDREFS }?,
  attribute participatingInstance { xsd:IDREFS }?,
  attribute participatingLink { xsd:IDREFS }?,
  attribute constrainingElement { xsd:IDREFS }?
CollaborationInstanceSet =
  element UML:CollaborationInstanceSet {
    attlist.CollaborationInstanceSet,
    UML.CollaborationInstanceSetFeatures*
  }
attlist.CollaborationInstanceSet &= UML.CollaborationInstanceSetAtts


# ========================= UML:Model_Management ===========================

# ========= UML:Package =========

Package.elementImport =
  element UML:Package.elementImport {
    attlist.Package.elementImport, ElementImport*
  }
attlist.Package.elementImport &= empty
UML.PackageFeatures =
  UML.GeneralizableElementFeatures
  | Namespace.ownedElement
  | Package.elementImport
UML.PackageAtts = UML.GeneralizableElementAtts
Package = element UML:Package { attlist.Package, UML.PackageFeatures* }
attlist.Package &= UML.PackageAtts

# ========= UML:Model =========
# A Model is just another name for a Package

UML.ModelFeatures = UML.PackageFeatures
UML.ModelAtts = UML.PackageAtts
Model = element UML:Model { attlist.Model, UML.ModelFeatures* }
attlist.Model &= UML.ModelAtts

# ========= UML:Subsystem =========
# Subsystem is co-derived from Classifier and Package

Subsystem.isInstantiable =
  element UML:Subsystem.isInstantiable {
    attlist.Subsystem.isInstantiable, empty
  }
attlist.Subsystem.isInstantiable &=
  attribute xmi.value { "true" | "false" }
UML.SubsystemFeatures =
  UML.PackageFeatures
  | Classifier.feature
  | Classifier.powertypeRange
  | Subsystem.isInstantiable
UML.SubsystemAtts =
  UML.PackageAtts,
  attribute powertypeRange { xsd:IDREFS }?,
  attribute isInstantiable { "true" | "false" }?
Subsystem =
  element UML:Subsystem { attlist.Subsystem, UML.SubsystemFeatures* }
attlist.Subsystem &= UML.SubsystemAtts

# ========= UML:ElementImport =========

ElementImport.visibility =
  element UML:ElementImport.visibility {
    attlist.ElementImport.visibility, empty
  }
attlist.ElementImport.visibility &=
  attribute xmi.value { UML.VisibilityKind }
ElementImport.alias =
  element UML:ElementImport.alias {
    attlist.ElementImport.alias, (text | XMI.reference)*
  }
attlist.ElementImport.alias &= empty
ElementImport.isSpecification =
  element UML:ElementImport.isSpecification {
    attlist.ElementImport.isSpecification, empty
  }
attlist.ElementImport.isSpecification &=
  attribute xmi.value { "true" | "false" }
ElementImport.package =
  element UML:ElementImport.package {
    attlist.ElementImport.package, Package*
  }
attlist.ElementImport.package &= empty
ElementImport.importedElement =
  element UML:ElementImport.importedElement {
    attlist.ElementImport.importedElement, ModelElement*
  }
attlist.ElementImport.importedElement &= empty
UML.ElementImportFeatures =
  XMI.extension
  | ElementImport.visibility
  | ElementImport.alias
  | ElementImport.isSpecification
  | ElementImport.package
  | ElementImport.importedElement
UML.ElementImportAtts =
  XMI.element.att,
  XMI.link.att,
  attribute visibility { UML.VisibilityKind }?,
  attribute alias { text }?,
  attribute isSpecification { "true" | "false" }?,
  attribute package { xsd:IDREFS }?,
  attribute importedElement { xsd:IDREFS }?
ElementImport =
  element UML:ElementImport {
    attlist.ElementImport, UML.ElementImportFeatures*
  }
attlist.ElementImport &= UML.ElementImportAtts


# ========= UML:Use_Cases =========

# ========= UML:UseCase =========

UseCase.extend =
  element UML:UseCase.extend { attlist.UseCase.extend, Extend* }
attlist.UseCase.extend &= empty
UseCase.include =
  element UML:UseCase.include { attlist.UseCase.include, Include* }
attlist.UseCase.include &= empty
UseCase.extensionPoint =
  element UML:UseCase.extensionPoint {
    attlist.UseCase.extensionPoint, ExtensionPoint*
  }
attlist.UseCase.extensionPoint &= empty
UML.UseCaseFeatures =
  UML.ClassifierFeatures
  | UseCase.extend
  | UseCase.include
  | UseCase.extensionPoint
UML.UseCaseAtts =
  UML.ClassifierAtts,
  attribute extend { xsd:IDREFS }?,
  attribute include { xsd:IDREFS }?
UseCase = element UML:UseCase { attlist.UseCase, UML.UseCaseFeatures* }
attlist.UseCase &= UML.UseCaseAtts

# ========= UML:Actor =========

UML.ActorFeatures = UML.ClassifierFeatures
UML.ActorAtts = UML.ClassifierAtts
Actor = element UML:Actor { attlist.Actor, UML.ActorFeatures* }
attlist.Actor &= UML.ActorAtts

# ========= UML:UseCaseInstance =========

UML.UseCaseInstanceFeatures = UML.InstanceFeatures
UML.UseCaseInstanceAtts = UML.InstanceAtts
UseCaseInstance =
  element UML:UseCaseInstance {
    attlist.UseCaseInstance, UML.UseCaseInstanceFeatures*
  }
attlist.UseCaseInstance &= UML.UseCaseInstanceAtts

# ========= UML:Extend =========

Extend.condition =
  element UML:Extend.condition {
    attlist.Extend.condition, BooleanExpression*
  }
attlist.Extend.condition &= empty
Extend.base = element UML:Extend.base { attlist.Extend.base, UseCase* }
attlist.Extend.base &= empty
Extend.extension =
  element UML:Extend.extension { attlist.Extend.extension, UseCase* }
attlist.Extend.extension &= empty
Extend.extensionPoint =
  element UML:Extend.extensionPoint {
    attlist.Extend.extensionPoint, ExtensionPoint*
  }
attlist.Extend.extensionPoint &= empty
UML.ExtendFeatures =
  UML.RelationshipFeatures
  | Extend.condition
  | Extend.base
  | Extend.extension
  | Extend.extensionPoint
UML.ExtendAtts =
  UML.RelationshipAtts,
  attribute base { xsd:IDREFS }?,
  attribute extension { xsd:IDREFS }?,
  attribute extensionPoint { xsd:IDREFS }?
Extend = element UML:Extend { attlist.Extend, UML.ExtendFeatures* }
attlist.Extend &= UML.ExtendAtts

# ========= UML:Include =========

Include.addition =
  element UML:Include.addition { attlist.Include.addition, UseCase* }
attlist.Include.addition &= empty
Include.base =
  element UML:Include.base { attlist.Include.base, UseCase* }
attlist.Include.base &= empty
UML.IncludeFeatures =
  UML.RelationshipFeatures | Include.addition | Include.base
UML.IncludeAtts =
  UML.RelationshipAtts,
  attribute addition { xsd:IDREFS }?,
  attribute base { xsd:IDREFS }?
Include = element UML:Include { attlist.Include, UML.IncludeFeatures* }
attlist.Include &= UML.IncludeAtts

# ========= UML:ExtensionPoint =========

ExtensionPoint.location =
  element UML:ExtensionPoint.location {
    attlist.ExtensionPoint.location, (text | XMI.reference)*
  }
attlist.ExtensionPoint.location &= empty
ExtensionPoint.useCase =
  element UML:ExtensionPoint.useCase {
    attlist.ExtensionPoint.useCase, UseCase*
  }
attlist.ExtensionPoint.useCase &= empty
UML.ExtensionPointFeatures =
  UML.ModelElementFeatures
  | ExtensionPoint.location
  | ExtensionPoint.useCase
UML.ExtensionPointAtts =
  UML.ModelElementAtts,
  attribute location { text }?,
  attribute useCase { xsd:IDREFS }?
ExtensionPoint =
  element UML:ExtensionPoint {
    attlist.ExtensionPoint, UML.ExtensionPointFeatures*
  }
attlist.ExtensionPoint &= UML.ExtensionPointAtts
start =
  JumpHandler
  | XMI
  | TerminateAction
  | UninterpretedAction
  | PresentationElement
  | XMI.exporterID
  | A_context_raisedSignal
  | Element
any =
  (element * {
     attribute * { text }*,
     any
   }
   | text)*


# ========= UML:UML =========
